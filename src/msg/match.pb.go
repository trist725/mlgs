// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: match.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type S2C_QuickMatchStart_E_Err_QuickMatchStart int32

const (
	S2C_QuickMatchStart_E_Err_ S2C_QuickMatchStart_E_Err_QuickMatchStart = 0
	// /成功
	S2C_QuickMatchStart_E_Err_Success S2C_QuickMatchStart_E_Err_QuickMatchStart = 1
	// /分配房间失败
	S2C_QuickMatchStart_E_Err_Room S2C_QuickMatchStart_E_Err_QuickMatchStart = 2
	// /其它错误
	S2C_QuickMatchStart_E_Err_UnKnown S2C_QuickMatchStart_E_Err_QuickMatchStart = 3
	// /钱不够
	S2C_QuickMatchStart_E_Err_NotEnoughMoney S2C_QuickMatchStart_E_Err_QuickMatchStart = 4
	// /已经在游戏中
	S2C_QuickMatchStart_E_Err_AlreadyInGame S2C_QuickMatchStart_E_Err_QuickMatchStart = 5
)

var S2C_QuickMatchStart_E_Err_QuickMatchStart_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Success",
	2: "E_Err_Room",
	3: "E_Err_UnKnown",
	4: "E_Err_NotEnoughMoney",
	5: "E_Err_AlreadyInGame",
}
var S2C_QuickMatchStart_E_Err_QuickMatchStart_value = map[string]int32{
	"E_Err_":               0,
	"E_Err_Success":        1,
	"E_Err_Room":           2,
	"E_Err_UnKnown":        3,
	"E_Err_NotEnoughMoney": 4,
	"E_Err_AlreadyInGame":  5,
}

func (x S2C_QuickMatchStart_E_Err_QuickMatchStart) String() string {
	return proto.EnumName(S2C_QuickMatchStart_E_Err_QuickMatchStart_name, int32(x))
}
func (S2C_QuickMatchStart_E_Err_QuickMatchStart) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{5, 0}
}

type S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom int32

const (
	S2C_PlayerLeaveRoom_E_Err_ S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 0
	// /成功
	S2C_PlayerLeaveRoom_E_Err_Success S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 1
	// /失败,对局中
	S2C_PlayerLeaveRoom_E_Err_Playing S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 2
	// /失败,其它
	S2C_PlayerLeaveRoom_E_Err_UnKnown S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 3
)

var S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Success",
	2: "E_Err_Playing",
	3: "E_Err_UnKnown",
}
var S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_value = map[string]int32{
	"E_Err_":        0,
	"E_Err_Success": 1,
	"E_Err_Playing": 2,
	"E_Err_UnKnown": 3,
}

func (x S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom) String() string {
	return proto.EnumName(S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name, int32(x))
}
func (S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{7, 0}
}

// /离开原因
type S2C_UpdatePlayerLeaveRoom_E_Err int32

const (
	S2C_UpdatePlayerLeaveRoom_E_Err_ S2C_UpdatePlayerLeaveRoom_E_Err = 0
	// /正常离开
	S2C_UpdatePlayerLeaveRoom_E_Err_Normal S2C_UpdatePlayerLeaveRoom_E_Err = 1
	// /钱不够被踢
	S2C_UpdatePlayerLeaveRoom_E_Err_Kick_NoMoney S2C_UpdatePlayerLeaveRoom_E_Err = 2
	// /失败,其它
	S2C_UpdatePlayerLeaveRoom_E_Err_UnKnown S2C_UpdatePlayerLeaveRoom_E_Err = 3
	// /掉线
	S2C_UpdatePlayerLeaveRoom_E_Err_DisConn S2C_UpdatePlayerLeaveRoom_E_Err = 4
	// /赛事场结束
	S2C_UpdatePlayerLeaveRoom_E_Err_Match_Over S2C_UpdatePlayerLeaveRoom_E_Err = 5
)

var S2C_UpdatePlayerLeaveRoom_E_Err_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Normal",
	2: "E_Err_Kick_NoMoney",
	3: "E_Err_UnKnown",
	4: "E_Err_DisConn",
	5: "E_Err_Match_Over",
}
var S2C_UpdatePlayerLeaveRoom_E_Err_value = map[string]int32{
	"E_Err_":             0,
	"E_Err_Normal":       1,
	"E_Err_Kick_NoMoney": 2,
	"E_Err_UnKnown":      3,
	"E_Err_DisConn":      4,
	"E_Err_Match_Over":   5,
}

func (x S2C_UpdatePlayerLeaveRoom_E_Err) String() string {
	return proto.EnumName(S2C_UpdatePlayerLeaveRoom_E_Err_name, int32(x))
}
func (S2C_UpdatePlayerLeaveRoom_E_Err) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{9, 0}
}

// /牌
type Card struct {
	// /花色,1-黑桃(Spade),2-红桃(Heart),3-方块(Diamond),4-梅花(Club)
	Color int32 `protobuf:"varint,1,opt,name=Color,proto3" json:"Color,omitempty"`
	// /牌值,2-14
	Num int32 `protobuf:"varint,2,opt,name=Num,proto3" json:"Num,omitempty"`
}

func (m *Card) Reset()         { *m = Card{} }
func (m *Card) String() string { return proto.CompactTextString(m) }
func (*Card) ProtoMessage()    {}
func (*Card) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{0}
}
func (m *Card) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Card) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Card.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Card) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Card.Merge(dst, src)
}
func (m *Card) XXX_Size() int {
	return m.Size()
}
func (m *Card) XXX_DiscardUnknown() {
	xxx_messageInfo_Card.DiscardUnknown(m)
}

var xxx_messageInfo_Card proto.InternalMessageInfo

func (m *Card) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *Card) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

// /当前最大牌型
type BestCombo struct {
	Cards []*Card `protobuf:"bytes,1,rep,name=Cards" json:"Cards,omitempty"`
	// /10-皇家同花顺,9-同花顺,8-四条(金刚),7-葫芦,6-通话
	// /5-顺子,4-三条,3-两队,2-对子,1-高牌
	Type int32 `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *BestCombo) Reset()         { *m = BestCombo{} }
func (m *BestCombo) String() string { return proto.CompactTextString(m) }
func (*BestCombo) ProtoMessage()    {}
func (*BestCombo) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{1}
}
func (m *BestCombo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BestCombo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BestCombo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BestCombo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BestCombo.Merge(dst, src)
}
func (m *BestCombo) XXX_Size() int {
	return m.Size()
}
func (m *BestCombo) XXX_DiscardUnknown() {
	xxx_messageInfo_BestCombo.DiscardUnknown(m)
}

var xxx_messageInfo_BestCombo proto.InternalMessageInfo

func (m *BestCombo) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *BestCombo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// / 玩家
type Player struct {
	// /用户Id
	UserId int64 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	// /玩家名
	NickName string `protobuf:"bytes,2,opt,name=NickName,proto3" json:"NickName,omitempty"`
	// /头像
	AvatarURL string `protobuf:"bytes,3,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// /在房间的位置
	Pos uint32 `protobuf:"varint,4,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /角色,0=普通玩家, 1=庄家，2=小盲, 3=大盲
	Role int32 `protobuf:"varint,5,opt,name=Role,proto3" json:"Role,omitempty"`
	// / 筹码
	Chip int64 `protobuf:"varint,6,opt,name=Chip,proto3" json:"Chip,omitempty"`
	// /已押注筹码
	BetChip int64 `protobuf:"varint,7,opt,name=BetChip,proto3" json:"BetChip,omitempty"`
	// /牌
	Cards []*Card `protobuf:"bytes,8,rep,name=Cards" json:"Cards,omitempty"`
	// /性别
	Sex string `protobuf:"bytes,9,opt,name=Sex,proto3" json:"Sex,omitempty"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{2}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(dst, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Player) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *Player) GetAvatarURL() string {
	if m != nil {
		return m.AvatarURL
	}
	return ""
}

func (m *Player) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *Player) GetRole() int32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *Player) GetChip() int64 {
	if m != nil {
		return m.Chip
	}
	return 0
}

func (m *Player) GetBetChip() int64 {
	if m != nil {
		return m.BetChip
	}
	return 0
}

func (m *Player) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *Player) GetSex() string {
	if m != nil {
		return m.Sex
	}
	return ""
}

// / 房间
type Room struct {
	// /房间号
	Id uint64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// /房间名
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// /房间玩家
	Players []*Player `protobuf:"bytes,3,rep,name=Players" json:"Players,omitempty"`
	// /房间奖池内的筹码
	Chip int64 `protobuf:"varint,4,opt,name=Chip,proto3" json:"Chip,omitempty"`
	// /当前最大加注
	MaxBet int64 `protobuf:"varint,5,opt,name=MaxBet,proto3" json:"MaxBet,omitempty"`
}

func (m *Room) Reset()         { *m = Room{} }
func (m *Room) String() string { return proto.CompactTextString(m) }
func (*Room) ProtoMessage()    {}
func (*Room) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{3}
}
func (m *Room) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Room) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Room.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Room) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Room.Merge(dst, src)
}
func (m *Room) XXX_Size() int {
	return m.Size()
}
func (m *Room) XXX_DiscardUnknown() {
	xxx_messageInfo_Room.DiscardUnknown(m)
}

var xxx_messageInfo_Room proto.InternalMessageInfo

func (m *Room) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Room) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Room) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *Room) GetChip() int64 {
	if m != nil {
		return m.Chip
	}
	return 0
}

func (m *Room) GetMaxBet() int64 {
	if m != nil {
		return m.MaxBet
	}
	return 0
}

// / 快速开始游戏请求
type C2S_QuickMatchStart struct {
	// /房间类型,room表里的id
	Type int64 `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *C2S_QuickMatchStart) Reset()         { *m = C2S_QuickMatchStart{} }
func (m *C2S_QuickMatchStart) String() string { return proto.CompactTextString(m) }
func (*C2S_QuickMatchStart) ProtoMessage()    {}
func (*C2S_QuickMatchStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{4}
}
func (m *C2S_QuickMatchStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_QuickMatchStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_QuickMatchStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_QuickMatchStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_QuickMatchStart.Merge(dst, src)
}
func (m *C2S_QuickMatchStart) XXX_Size() int {
	return m.Size()
}
func (m *C2S_QuickMatchStart) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_QuickMatchStart.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_QuickMatchStart proto.InternalMessageInfo

func (m *C2S_QuickMatchStart) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

// / 快速开始游戏回复
type S2C_QuickMatchStart struct {
	Err  S2C_QuickMatchStart_E_Err_QuickMatchStart `protobuf:"varint,1,opt,name=Err,proto3,enum=msg.S2C_QuickMatchStart_E_Err_QuickMatchStart" json:"Err,omitempty"`
	Room *Room                                     `protobuf:"bytes,2,opt,name=Room" json:"Room,omitempty"`
}

func (m *S2C_QuickMatchStart) Reset()         { *m = S2C_QuickMatchStart{} }
func (m *S2C_QuickMatchStart) String() string { return proto.CompactTextString(m) }
func (*S2C_QuickMatchStart) ProtoMessage()    {}
func (*S2C_QuickMatchStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{5}
}
func (m *S2C_QuickMatchStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_QuickMatchStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_QuickMatchStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_QuickMatchStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_QuickMatchStart.Merge(dst, src)
}
func (m *S2C_QuickMatchStart) XXX_Size() int {
	return m.Size()
}
func (m *S2C_QuickMatchStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_QuickMatchStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_QuickMatchStart proto.InternalMessageInfo

func (m *S2C_QuickMatchStart) GetErr() S2C_QuickMatchStart_E_Err_QuickMatchStart {
	if m != nil {
		return m.Err
	}
	return S2C_QuickMatchStart_E_Err_
}

func (m *S2C_QuickMatchStart) GetRoom() *Room {
	if m != nil {
		return m.Room
	}
	return nil
}

// / 玩家离开房间请求
type C2S_PlayerLeaveRoom struct {
}

func (m *C2S_PlayerLeaveRoom) Reset()         { *m = C2S_PlayerLeaveRoom{} }
func (m *C2S_PlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*C2S_PlayerLeaveRoom) ProtoMessage()    {}
func (*C2S_PlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{6}
}
func (m *C2S_PlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_PlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_PlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_PlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_PlayerLeaveRoom.Merge(dst, src)
}
func (m *C2S_PlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2S_PlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_PlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_PlayerLeaveRoom proto.InternalMessageInfo

// / 玩家离开房间回复
type S2C_PlayerLeaveRoom struct {
	Err S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom `protobuf:"varint,1,opt,name=Err,proto3,enum=msg.S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom" json:"Err,omitempty"`
}

func (m *S2C_PlayerLeaveRoom) Reset()         { *m = S2C_PlayerLeaveRoom{} }
func (m *S2C_PlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_PlayerLeaveRoom) ProtoMessage()    {}
func (*S2C_PlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{7}
}
func (m *S2C_PlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_PlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_PlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_PlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_PlayerLeaveRoom.Merge(dst, src)
}
func (m *S2C_PlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_PlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_PlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_PlayerLeaveRoom proto.InternalMessageInfo

func (m *S2C_PlayerLeaveRoom) GetErr() S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom {
	if m != nil {
		return m.Err
	}
	return S2C_PlayerLeaveRoom_E_Err_
}

// / 玩家加入房间
type S2C_UpdatePlayerJoinRoom struct {
	Players []*Player `protobuf:"bytes,1,rep,name=Players" json:"Players,omitempty"`
}

func (m *S2C_UpdatePlayerJoinRoom) Reset()         { *m = S2C_UpdatePlayerJoinRoom{} }
func (m *S2C_UpdatePlayerJoinRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_UpdatePlayerJoinRoom) ProtoMessage()    {}
func (*S2C_UpdatePlayerJoinRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{8}
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_UpdatePlayerJoinRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_UpdatePlayerJoinRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_UpdatePlayerJoinRoom.Merge(dst, src)
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_UpdatePlayerJoinRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_UpdatePlayerJoinRoom proto.InternalMessageInfo

func (m *S2C_UpdatePlayerJoinRoom) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// / 玩家离开房间
type S2C_UpdatePlayerLeaveRoom struct {
	// /离开的玩家的用户id
	UserId int64                           `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Reason S2C_UpdatePlayerLeaveRoom_E_Err `protobuf:"varint,4,opt,name=Reason,proto3,enum=msg.S2C_UpdatePlayerLeaveRoom_E_Err" json:"Reason,omitempty"`
}

func (m *S2C_UpdatePlayerLeaveRoom) Reset()         { *m = S2C_UpdatePlayerLeaveRoom{} }
func (m *S2C_UpdatePlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_UpdatePlayerLeaveRoom) ProtoMessage()    {}
func (*S2C_UpdatePlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{9}
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_UpdatePlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.Merge(dst, src)
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_UpdatePlayerLeaveRoom proto.InternalMessageInfo

func (m *S2C_UpdatePlayerLeaveRoom) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *S2C_UpdatePlayerLeaveRoom) GetReason() S2C_UpdatePlayerLeaveRoom_E_Err {
	if m != nil {
		return m.Reason
	}
	return S2C_UpdatePlayerLeaveRoom_E_Err_
}

// / 开局
type S2C_GameStart struct {
	// /庄家位置
	Pos uint32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /牌
	Cards []*Card `protobuf:"bytes,2,rep,name=Cards" json:"Cards,omitempty"`
	// /初始小盲注
	SmallBlind int64 `protobuf:"varint,3,opt,name=SmallBlind,proto3" json:"SmallBlind,omitempty"`
	// /最大牌型
	Best *BestCombo `protobuf:"bytes,4,opt,name=Best" json:"Best,omitempty"`
	// /本次赛事场第几局
	Round int32 `protobuf:"varint,5,opt,name=Round,proto3" json:"Round,omitempty"`
}

func (m *S2C_GameStart) Reset()         { *m = S2C_GameStart{} }
func (m *S2C_GameStart) String() string { return proto.CompactTextString(m) }
func (*S2C_GameStart) ProtoMessage()    {}
func (*S2C_GameStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{10}
}
func (m *S2C_GameStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_GameStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_GameStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_GameStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_GameStart.Merge(dst, src)
}
func (m *S2C_GameStart) XXX_Size() int {
	return m.Size()
}
func (m *S2C_GameStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_GameStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_GameStart proto.InternalMessageInfo

func (m *S2C_GameStart) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *S2C_GameStart) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *S2C_GameStart) GetSmallBlind() int64 {
	if m != nil {
		return m.SmallBlind
	}
	return 0
}

func (m *S2C_GameStart) GetBest() *BestCombo {
	if m != nil {
		return m.Best
	}
	return nil
}

func (m *S2C_GameStart) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

// /当前轮到谁操作
type S2C_Turn struct {
	// /位置
	Pos uint32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /是否有自动操作,0-否,1-是
	Auto int32 `protobuf:"varint,2,opt,name=Auto,proto3" json:"Auto,omitempty"`
}

func (m *S2C_Turn) Reset()         { *m = S2C_Turn{} }
func (m *S2C_Turn) String() string { return proto.CompactTextString(m) }
func (*S2C_Turn) ProtoMessage()    {}
func (*S2C_Turn) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{11}
}
func (m *S2C_Turn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_Turn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_Turn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_Turn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_Turn.Merge(dst, src)
}
func (m *S2C_Turn) XXX_Size() int {
	return m.Size()
}
func (m *S2C_Turn) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_Turn.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_Turn proto.InternalMessageInfo

func (m *S2C_Turn) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *S2C_Turn) GetAuto() int32 {
	if m != nil {
		return m.Auto
	}
	return 0
}

// /玩家操作
type C2S_TurnAction struct {
	// /操作,1-让牌,2-弃牌,3-跟注,4-加注,5-Allin
	Act int32 `protobuf:"varint,1,opt,name=Act,proto3" json:"Act,omitempty"`
	// /加注值
	Bet int64 `protobuf:"varint,2,opt,name=Bet,proto3" json:"Bet,omitempty"`
}

func (m *C2S_TurnAction) Reset()         { *m = C2S_TurnAction{} }
func (m *C2S_TurnAction) String() string { return proto.CompactTextString(m) }
func (*C2S_TurnAction) ProtoMessage()    {}
func (*C2S_TurnAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{12}
}
func (m *C2S_TurnAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_TurnAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_TurnAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_TurnAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_TurnAction.Merge(dst, src)
}
func (m *C2S_TurnAction) XXX_Size() int {
	return m.Size()
}
func (m *C2S_TurnAction) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_TurnAction.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_TurnAction proto.InternalMessageInfo

func (m *C2S_TurnAction) GetAct() int32 {
	if m != nil {
		return m.Act
	}
	return 0
}

func (m *C2S_TurnAction) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

// /玩家操作回复,实际操作
type S2C_TurnAction struct {
	// /1-让牌,2-弃牌,3-跟注,4-加注,5-Allin
	Act int32 `protobuf:"varint,1,opt,name=Act,proto3" json:"Act,omitempty"`
	// /实际下注值
	Bet int64 `protobuf:"varint,2,opt,name=Bet,proto3" json:"Bet,omitempty"`
	// /玩家位置
	Pos int32 `protobuf:"varint,3,opt,name=pos,proto3" json:"pos,omitempty"`
}

func (m *S2C_TurnAction) Reset()         { *m = S2C_TurnAction{} }
func (m *S2C_TurnAction) String() string { return proto.CompactTextString(m) }
func (*S2C_TurnAction) ProtoMessage()    {}
func (*S2C_TurnAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{13}
}
func (m *S2C_TurnAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_TurnAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_TurnAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_TurnAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_TurnAction.Merge(dst, src)
}
func (m *S2C_TurnAction) XXX_Size() int {
	return m.Size()
}
func (m *S2C_TurnAction) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_TurnAction.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_TurnAction proto.InternalMessageInfo

func (m *S2C_TurnAction) GetAct() int32 {
	if m != nil {
		return m.Act
	}
	return 0
}

func (m *S2C_TurnAction) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *S2C_TurnAction) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// /发公共牌
type S2C_PublicCard struct {
	// /公共牌
	Cards []*Card `protobuf:"bytes,1,rep,name=Cards" json:"Cards,omitempty"`
	// /最大牌型
	Best *BestCombo `protobuf:"bytes,3,opt,name=Best" json:"Best,omitempty"`
}

func (m *S2C_PublicCard) Reset()         { *m = S2C_PublicCard{} }
func (m *S2C_PublicCard) String() string { return proto.CompactTextString(m) }
func (*S2C_PublicCard) ProtoMessage()    {}
func (*S2C_PublicCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{14}
}
func (m *S2C_PublicCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_PublicCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_PublicCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_PublicCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_PublicCard.Merge(dst, src)
}
func (m *S2C_PublicCard) XXX_Size() int {
	return m.Size()
}
func (m *S2C_PublicCard) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_PublicCard.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_PublicCard proto.InternalMessageInfo

func (m *S2C_PublicCard) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *S2C_PublicCard) GetBest() *BestCombo {
	if m != nil {
		return m.Best
	}
	return nil
}

// /勾选自动操作
type C2S_AutoAction struct {
	// /0-无勾选,1-让牌,2-弃牌,3-跟注,4-跟任何注
	Act int32 `protobuf:"varint,1,opt,name=Act,proto3" json:"Act,omitempty"`
}

func (m *C2S_AutoAction) Reset()         { *m = C2S_AutoAction{} }
func (m *C2S_AutoAction) String() string { return proto.CompactTextString(m) }
func (*C2S_AutoAction) ProtoMessage()    {}
func (*C2S_AutoAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{15}
}
func (m *C2S_AutoAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_AutoAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_AutoAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_AutoAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_AutoAction.Merge(dst, src)
}
func (m *C2S_AutoAction) XXX_Size() int {
	return m.Size()
}
func (m *C2S_AutoAction) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_AutoAction.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_AutoAction proto.InternalMessageInfo

func (m *C2S_AutoAction) GetAct() int32 {
	if m != nil {
		return m.Act
	}
	return 0
}

// /游戏结束
type S2C_GameOver struct {
}

func (m *S2C_GameOver) Reset()         { *m = S2C_GameOver{} }
func (m *S2C_GameOver) String() string { return proto.CompactTextString(m) }
func (*S2C_GameOver) ProtoMessage()    {}
func (*S2C_GameOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{16}
}
func (m *S2C_GameOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_GameOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_GameOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_GameOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_GameOver.Merge(dst, src)
}
func (m *S2C_GameOver) XXX_Size() int {
	return m.Size()
}
func (m *S2C_GameOver) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_GameOver.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_GameOver proto.InternalMessageInfo

// /结算
type Balance struct {
	// /用户Id
	UserId int64 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	// /最大牌型
	BestCombo *BestCombo `protobuf:"bytes,2,opt,name=BestCombo" json:"BestCombo,omitempty"`
	// /输赢的筹码,负数为输
	Gain int64 `protobuf:"varint,3,opt,name=Gain,proto3" json:"Gain,omitempty"`
	// /退回多余的筹码
	Refund int64 `protobuf:"varint,4,opt,name=Refund,proto3" json:"Refund,omitempty"`
	// /手牌
	Cards []*Card `protobuf:"bytes,5,rep,name=Cards" json:"Cards,omitempty"`
	// /本次赛事场胜场
	WinRound int32 `protobuf:"varint,6,opt,name=WinRound,proto3" json:"WinRound,omitempty"`
}

func (m *Balance) Reset()         { *m = Balance{} }
func (m *Balance) String() string { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()    {}
func (*Balance) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{17}
}
func (m *Balance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Balance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Balance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Balance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Balance.Merge(dst, src)
}
func (m *Balance) XXX_Size() int {
	return m.Size()
}
func (m *Balance) XXX_DiscardUnknown() {
	xxx_messageInfo_Balance.DiscardUnknown(m)
}

var xxx_messageInfo_Balance proto.InternalMessageInfo

func (m *Balance) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Balance) GetBestCombo() *BestCombo {
	if m != nil {
		return m.BestCombo
	}
	return nil
}

func (m *Balance) GetGain() int64 {
	if m != nil {
		return m.Gain
	}
	return 0
}

func (m *Balance) GetRefund() int64 {
	if m != nil {
		return m.Refund
	}
	return 0
}

func (m *Balance) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *Balance) GetWinRound() int32 {
	if m != nil {
		return m.WinRound
	}
	return 0
}

// /下发结算消息
type S2C_Balance struct {
	// /所有人的结算信息
	Balances []*Balance `protobuf:"bytes,1,rep,name=Balances" json:"Balances,omitempty"`
}

func (m *S2C_Balance) Reset()         { *m = S2C_Balance{} }
func (m *S2C_Balance) String() string { return proto.CompactTextString(m) }
func (*S2C_Balance) ProtoMessage()    {}
func (*S2C_Balance) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{18}
}
func (m *S2C_Balance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_Balance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_Balance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_Balance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_Balance.Merge(dst, src)
}
func (m *S2C_Balance) XXX_Size() int {
	return m.Size()
}
func (m *S2C_Balance) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_Balance.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_Balance proto.InternalMessageInfo

func (m *S2C_Balance) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// /聊天请求
type C2S_RoomChat struct {
	// /用户id
	SrcUserId int64 `protobuf:"varint,1,opt,name=SrcUserId,proto3" json:"SrcUserId,omitempty"`
	// /目标用户id
	DstUserId int64 `protobuf:"varint,2,opt,name=DstUserId,proto3" json:"DstUserId,omitempty"`
	// /内容
	Content string `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *C2S_RoomChat) Reset()         { *m = C2S_RoomChat{} }
func (m *C2S_RoomChat) String() string { return proto.CompactTextString(m) }
func (*C2S_RoomChat) ProtoMessage()    {}
func (*C2S_RoomChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{19}
}
func (m *C2S_RoomChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_RoomChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_RoomChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_RoomChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_RoomChat.Merge(dst, src)
}
func (m *C2S_RoomChat) XXX_Size() int {
	return m.Size()
}
func (m *C2S_RoomChat) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_RoomChat.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_RoomChat proto.InternalMessageInfo

func (m *C2S_RoomChat) GetSrcUserId() int64 {
	if m != nil {
		return m.SrcUserId
	}
	return 0
}

func (m *C2S_RoomChat) GetDstUserId() int64 {
	if m != nil {
		return m.DstUserId
	}
	return 0
}

func (m *C2S_RoomChat) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// /聊天回复
type S2C_RoomChat struct {
	// /用户id
	SrcUserId int64 `protobuf:"varint,1,opt,name=SrcUserId,proto3" json:"SrcUserId,omitempty"`
	// /目标用户id
	DstUserId int64 `protobuf:"varint,2,opt,name=DstUserId,proto3" json:"DstUserId,omitempty"`
	// /内容
	Content string `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *S2C_RoomChat) Reset()         { *m = S2C_RoomChat{} }
func (m *S2C_RoomChat) String() string { return proto.CompactTextString(m) }
func (*S2C_RoomChat) ProtoMessage()    {}
func (*S2C_RoomChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_15cb4d67518ea3ba, []int{20}
}
func (m *S2C_RoomChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_RoomChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_RoomChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_RoomChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_RoomChat.Merge(dst, src)
}
func (m *S2C_RoomChat) XXX_Size() int {
	return m.Size()
}
func (m *S2C_RoomChat) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_RoomChat.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_RoomChat proto.InternalMessageInfo

func (m *S2C_RoomChat) GetSrcUserId() int64 {
	if m != nil {
		return m.SrcUserId
	}
	return 0
}

func (m *S2C_RoomChat) GetDstUserId() int64 {
	if m != nil {
		return m.DstUserId
	}
	return 0
}

func (m *S2C_RoomChat) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func init() {
	proto.RegisterType((*Card)(nil), "msg.Card")
	proto.RegisterType((*BestCombo)(nil), "msg.BestCombo")
	proto.RegisterType((*Player)(nil), "msg.Player")
	proto.RegisterType((*Room)(nil), "msg.Room")
	proto.RegisterType((*C2S_QuickMatchStart)(nil), "msg.C2S_QuickMatchStart")
	proto.RegisterType((*S2C_QuickMatchStart)(nil), "msg.S2C_QuickMatchStart")
	proto.RegisterType((*C2S_PlayerLeaveRoom)(nil), "msg.C2S_PlayerLeaveRoom")
	proto.RegisterType((*S2C_PlayerLeaveRoom)(nil), "msg.S2C_PlayerLeaveRoom")
	proto.RegisterType((*S2C_UpdatePlayerJoinRoom)(nil), "msg.S2C_UpdatePlayerJoinRoom")
	proto.RegisterType((*S2C_UpdatePlayerLeaveRoom)(nil), "msg.S2C_UpdatePlayerLeaveRoom")
	proto.RegisterType((*S2C_GameStart)(nil), "msg.S2C_GameStart")
	proto.RegisterType((*S2C_Turn)(nil), "msg.S2C_Turn")
	proto.RegisterType((*C2S_TurnAction)(nil), "msg.C2S_TurnAction")
	proto.RegisterType((*S2C_TurnAction)(nil), "msg.S2C_TurnAction")
	proto.RegisterType((*S2C_PublicCard)(nil), "msg.S2C_PublicCard")
	proto.RegisterType((*C2S_AutoAction)(nil), "msg.C2S_AutoAction")
	proto.RegisterType((*S2C_GameOver)(nil), "msg.S2C_GameOver")
	proto.RegisterType((*Balance)(nil), "msg.Balance")
	proto.RegisterType((*S2C_Balance)(nil), "msg.S2C_Balance")
	proto.RegisterType((*C2S_RoomChat)(nil), "msg.C2S_RoomChat")
	proto.RegisterType((*S2C_RoomChat)(nil), "msg.S2C_RoomChat")
	proto.RegisterEnum("msg.S2C_QuickMatchStart_E_Err_QuickMatchStart", S2C_QuickMatchStart_E_Err_QuickMatchStart_name, S2C_QuickMatchStart_E_Err_QuickMatchStart_value)
	proto.RegisterEnum("msg.S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom", S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name, S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_value)
	proto.RegisterEnum("msg.S2C_UpdatePlayerLeaveRoom_E_Err", S2C_UpdatePlayerLeaveRoom_E_Err_name, S2C_UpdatePlayerLeaveRoom_E_Err_value)
}
func (m *Card) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Card) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Color != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Color))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *BestCombo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BestCombo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.UserId))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.AvatarURL) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.AvatarURL)))
		i += copy(dAtA[i:], m.AvatarURL)
	}
	if m.Pos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if m.Role != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Role))
	}
	if m.Chip != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Chip))
	}
	if m.BetChip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.BetChip))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Sex) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Sex)))
		i += copy(dAtA[i:], m.Sex)
	}
	return i, nil
}

func (m *Room) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Room) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Chip != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Chip))
	}
	if m.MaxBet != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.MaxBet))
	}
	return i, nil
}

func (m *C2S_QuickMatchStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_QuickMatchStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *S2C_QuickMatchStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_QuickMatchStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Err))
	}
	if m.Room != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Room.Size()))
		n1, err := m.Room.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *C2S_PlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_PlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *S2C_PlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_PlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Err))
	}
	return i, nil
}

func (m *S2C_UpdatePlayerJoinRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_UpdatePlayerJoinRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *S2C_UpdatePlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_UpdatePlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.UserId))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *S2C_GameStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_GameStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SmallBlind != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.SmallBlind))
	}
	if m.Best != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Best.Size()))
		n2, err := m.Best.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Round != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Round))
	}
	return i, nil
}

func (m *S2C_Turn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_Turn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if m.Auto != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Auto))
	}
	return i, nil
}

func (m *C2S_TurnAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_TurnAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Act != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Act))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Bet))
	}
	return i, nil
}

func (m *S2C_TurnAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_TurnAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Act != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Act))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Bet))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	return i, nil
}

func (m *S2C_PublicCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_PublicCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Best != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Best.Size()))
		n3, err := m.Best.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *C2S_AutoAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_AutoAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Act != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Act))
	}
	return i, nil
}

func (m *S2C_GameOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_GameOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Balance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Balance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.UserId))
	}
	if m.BestCombo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.BestCombo.Size()))
		n4, err := m.BestCombo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Gain != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Gain))
	}
	if m.Refund != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Refund))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WinRound != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.WinRound))
	}
	return i, nil
}

func (m *S2C_Balance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_Balance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, msg := range m.Balances {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C2S_RoomChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_RoomChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcUserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.SrcUserId))
	}
	if m.DstUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.DstUserId))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *S2C_RoomChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_RoomChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcUserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.SrcUserId))
	}
	if m.DstUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.DstUserId))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func encodeVarintMatch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Card) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != 0 {
		n += 1 + sovMatch(uint64(m.Color))
	}
	if m.Num != 0 {
		n += 1 + sovMatch(uint64(m.Num))
	}
	return n
}

func (m *BestCombo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovMatch(uint64(m.Type))
	}
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMatch(uint64(m.UserId))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if m.Role != 0 {
		n += 1 + sovMatch(uint64(m.Role))
	}
	if m.Chip != 0 {
		n += 1 + sovMatch(uint64(m.Chip))
	}
	if m.BetChip != 0 {
		n += 1 + sovMatch(uint64(m.BetChip))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	l = len(m.Sex)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *Room) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMatch(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.Chip != 0 {
		n += 1 + sovMatch(uint64(m.Chip))
	}
	if m.MaxBet != 0 {
		n += 1 + sovMatch(uint64(m.MaxBet))
	}
	return n
}

func (m *C2S_QuickMatchStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMatch(uint64(m.Type))
	}
	return n
}

func (m *S2C_QuickMatchStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != 0 {
		n += 1 + sovMatch(uint64(m.Err))
	}
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *C2S_PlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2C_PlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != 0 {
		n += 1 + sovMatch(uint64(m.Err))
	}
	return n
}

func (m *S2C_UpdatePlayerJoinRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	return n
}

func (m *S2C_UpdatePlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMatch(uint64(m.UserId))
	}
	if m.Reason != 0 {
		n += 1 + sovMatch(uint64(m.Reason))
	}
	return n
}

func (m *S2C_GameStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.SmallBlind != 0 {
		n += 1 + sovMatch(uint64(m.SmallBlind))
	}
	if m.Best != nil {
		l = m.Best.Size()
		n += 1 + l + sovMatch(uint64(l))
	}
	if m.Round != 0 {
		n += 1 + sovMatch(uint64(m.Round))
	}
	return n
}

func (m *S2C_Turn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if m.Auto != 0 {
		n += 1 + sovMatch(uint64(m.Auto))
	}
	return n
}

func (m *C2S_TurnAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Act != 0 {
		n += 1 + sovMatch(uint64(m.Act))
	}
	if m.Bet != 0 {
		n += 1 + sovMatch(uint64(m.Bet))
	}
	return n
}

func (m *S2C_TurnAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Act != 0 {
		n += 1 + sovMatch(uint64(m.Act))
	}
	if m.Bet != 0 {
		n += 1 + sovMatch(uint64(m.Bet))
	}
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	return n
}

func (m *S2C_PublicCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.Best != nil {
		l = m.Best.Size()
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *C2S_AutoAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Act != 0 {
		n += 1 + sovMatch(uint64(m.Act))
	}
	return n
}

func (m *S2C_GameOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Balance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMatch(uint64(m.UserId))
	}
	if m.BestCombo != nil {
		l = m.BestCombo.Size()
		n += 1 + l + sovMatch(uint64(l))
	}
	if m.Gain != 0 {
		n += 1 + sovMatch(uint64(m.Gain))
	}
	if m.Refund != 0 {
		n += 1 + sovMatch(uint64(m.Refund))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.WinRound != 0 {
		n += 1 + sovMatch(uint64(m.WinRound))
	}
	return n
}

func (m *S2C_Balance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	return n
}

func (m *C2S_RoomChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcUserId != 0 {
		n += 1 + sovMatch(uint64(m.SrcUserId))
	}
	if m.DstUserId != 0 {
		n += 1 + sovMatch(uint64(m.DstUserId))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *S2C_RoomChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcUserId != 0 {
		n += 1 + sovMatch(uint64(m.SrcUserId))
	}
	if m.DstUserId != 0 {
		n += 1 + sovMatch(uint64(m.DstUserId))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func sovMatch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMatch(x uint64) (n int) {
	return sovMatch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Card) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BestCombo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BestCombo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BestCombo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetChip", wireType)
			}
			m.BetChip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetChip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Room) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Room: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Room: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBet", wireType)
			}
			m.MaxBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_QuickMatchStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_QuickMatchStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_QuickMatchStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_QuickMatchStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_QuickMatchStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_QuickMatchStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (S2C_QuickMatchStart_E_Err_QuickMatchStart(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &Room{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_PlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_PlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_PlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_PlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_PlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_PlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_UpdatePlayerJoinRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_UpdatePlayerJoinRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_UpdatePlayerJoinRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_UpdatePlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_UpdatePlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_UpdatePlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (S2C_UpdatePlayerLeaveRoom_E_Err(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_GameStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_GameStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_GameStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallBlind", wireType)
			}
			m.SmallBlind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmallBlind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Best == nil {
				m.Best = &BestCombo{}
			}
			if err := m.Best.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_Turn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_Turn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_Turn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			m.Auto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Auto |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_TurnAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_TurnAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_TurnAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			m.Act = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Act |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_TurnAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_TurnAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_TurnAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			m.Act = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Act |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_PublicCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_PublicCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_PublicCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Best", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Best == nil {
				m.Best = &BestCombo{}
			}
			if err := m.Best.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_AutoAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_AutoAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_AutoAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			m.Act = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Act |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_GameOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_GameOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_GameOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Balance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestCombo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BestCombo == nil {
				m.BestCombo = &BestCombo{}
			}
			if err := m.BestCombo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gain", wireType)
			}
			m.Gain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gain |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refund", wireType)
			}
			m.Refund = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refund |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinRound", wireType)
			}
			m.WinRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinRound |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_Balance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_Balance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_Balance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_RoomChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_RoomChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_RoomChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUserId", wireType)
			}
			m.SrcUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUserId", wireType)
			}
			m.DstUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_RoomChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_RoomChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_RoomChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUserId", wireType)
			}
			m.SrcUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUserId", wireType)
			}
			m.DstUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMatch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMatch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMatch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMatch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMatch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("match.proto", fileDescriptor_match_15cb4d67518ea3ba) }

var fileDescriptor_match_15cb4d67518ea3ba = []byte{
	// 946 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0x63, 0x3b, 0x6d, 0x5e, 0xda, 0xc8, 0x4c, 0xbb, 0xc5, 0xac, 0x20, 0x54, 0x23, 0x90,
	0x8a, 0x84, 0x22, 0x14, 0x90, 0xb8, 0x70, 0xd8, 0xc4, 0x5b, 0x56, 0x65, 0xb7, 0xa1, 0x4c, 0x36,
	0xe2, 0x82, 0x54, 0x4d, 0x9d, 0xa1, 0xb5, 0x6a, 0xcf, 0x44, 0xb6, 0x53, 0x36, 0x07, 0x8e, 0xdc,
	0x38, 0xf0, 0x03, 0xf8, 0x1b, 0x48, 0xfc, 0x04, 0x8e, 0x7b, 0xe4, 0x08, 0xed, 0x95, 0x1f, 0x81,
	0xde, 0x8c, 0xed, 0x64, 0x43, 0xac, 0xe5, 0xb2, 0xb7, 0xf7, 0xbe, 0xf1, 0x9b, 0xf7, 0xbd, 0xef,
	0xbd, 0xbc, 0x09, 0xb4, 0x13, 0x9e, 0x87, 0xd7, 0xbd, 0x59, 0xaa, 0x72, 0x45, 0xec, 0x24, 0xbb,
	0xa2, 0x3d, 0x70, 0x02, 0x9e, 0x4e, 0xc9, 0x01, 0xb8, 0x81, 0x8a, 0x55, 0xea, 0x5b, 0x47, 0xd6,
	0xb1, 0xcb, 0x8c, 0x43, 0x3c, 0xb0, 0x47, 0xf3, 0xc4, 0x6f, 0x68, 0x0c, 0x4d, 0xfa, 0x08, 0x5a,
	0x43, 0x91, 0xe5, 0x81, 0x4a, 0x2e, 0x15, 0x79, 0x1f, 0x5c, 0x0c, 0xce, 0x7c, 0xeb, 0xc8, 0x3e,
	0x6e, 0xf7, 0x5b, 0xbd, 0x24, 0xbb, 0xea, 0x21, 0xc2, 0x0c, 0x4e, 0x08, 0x38, 0xcf, 0x17, 0x33,
	0x51, 0x5c, 0xa0, 0x6d, 0xfa, 0xb7, 0x05, 0xcd, 0xf3, 0x98, 0x2f, 0x44, 0x4a, 0x0e, 0xa1, 0x39,
	0xc9, 0x44, 0x7a, 0x3a, 0xd5, 0x59, 0x6d, 0x56, 0x78, 0xe4, 0x21, 0xec, 0x8c, 0xa2, 0xf0, 0x66,
	0xc4, 0x13, 0x13, 0xda, 0x62, 0x95, 0x4f, 0xde, 0x85, 0xd6, 0xe0, 0x96, 0xe7, 0x3c, 0x9d, 0xb0,
	0x67, 0xbe, 0xad, 0x0f, 0x97, 0x00, 0x12, 0x3e, 0x57, 0x99, 0xef, 0x1c, 0x59, 0xc7, 0x7b, 0x0c,
	0x4d, 0xa4, 0xc0, 0x54, 0x2c, 0x7c, 0xd7, 0x50, 0x40, 0x1b, 0xb1, 0xe0, 0x3a, 0x9a, 0xf9, 0x4d,
	0x9d, 0x55, 0xdb, 0xc4, 0x87, 0xed, 0xa1, 0xc8, 0x35, 0xbc, 0xad, 0xe1, 0xd2, 0x5d, 0x56, 0xb9,
	0x53, 0x53, 0xa5, 0x07, 0xf6, 0x58, 0xbc, 0xf0, 0x5b, 0x9a, 0x0c, 0x9a, 0xf4, 0x47, 0x4c, 0xaa,
	0x12, 0xd2, 0x81, 0x46, 0x51, 0x9c, 0xc3, 0x1a, 0xa7, 0x53, 0x4c, 0xbc, 0x52, 0x94, 0xb6, 0xc9,
	0x87, 0xb0, 0x6d, 0xe4, 0xc8, 0x7c, 0x5b, 0x27, 0x68, 0xeb, 0x04, 0x06, 0x63, 0xe5, 0x59, 0xc5,
	0xd9, 0x59, 0xe1, 0x7c, 0x08, 0xcd, 0x33, 0xfe, 0x62, 0x28, 0x72, 0x5d, 0x9d, 0xcd, 0x0a, 0x8f,
	0x7e, 0x04, 0xfb, 0x41, 0x7f, 0x7c, 0xf1, 0xcd, 0x3c, 0x0a, 0x6f, 0xce, 0xb0, 0xe3, 0xe3, 0x9c,
	0xa7, 0x79, 0xd5, 0x0d, 0x23, 0xb6, 0xe9, 0xc6, 0x4f, 0x0d, 0xd8, 0x1f, 0xf7, 0x83, 0xff, 0x7c,
	0xfb, 0x08, 0xec, 0x93, 0xd4, 0x4c, 0x43, 0xa7, 0xdf, 0xd3, 0x8c, 0x36, 0x7c, 0xd6, 0x3b, 0xb9,
	0x38, 0x49, 0xd3, 0x75, 0x94, 0x61, 0x28, 0x79, 0xcf, 0x68, 0xa0, 0x6b, 0x2d, 0x55, 0x43, 0x80,
	0x69, 0x98, 0xfe, 0x6c, 0xc1, 0x83, 0x8d, 0xd1, 0x04, 0xa0, 0x69, 0x0e, 0xbc, 0x2d, 0xf2, 0x16,
	0xec, 0x19, 0x7b, 0x3c, 0x0f, 0x43, 0x91, 0x65, 0x9e, 0x45, 0x3a, 0x00, 0x06, 0xc2, 0x6b, 0xbc,
	0xc6, 0xf2, 0x93, 0x89, 0x7c, 0x2a, 0xd5, 0x0f, 0xd2, 0xb3, 0x89, 0x0f, 0x07, 0x06, 0x1a, 0xa9,
	0xfc, 0x44, 0xaa, 0xf9, 0xd5, 0xf5, 0x99, 0x92, 0x62, 0xe1, 0x39, 0xe4, 0x6d, 0xd8, 0x37, 0x27,
	0x83, 0x38, 0x15, 0x7c, 0xba, 0x38, 0x95, 0x4f, 0x78, 0x22, 0x3c, 0x97, 0x3e, 0x30, 0x92, 0x19,
	0xb5, 0x9f, 0x09, 0x7e, 0x2b, 0x34, 0xcb, 0xdf, 0x2c, 0x23, 0xcf, 0x1a, 0x5e, 0x27, 0xcf, 0xda,
	0x67, 0x85, 0x3c, 0x6b, 0xa8, 0x96, 0x87, 0x7e, 0x57, 0x96, 0xbf, 0x7e, 0xf5, 0x6b, 0xca, 0xaf,
	0x20, 0x8c, 0x8b, 0xe4, 0xd5, 0x46, 0x05, 0xe8, 0x00, 0x7c, 0xe4, 0x33, 0x99, 0x4d, 0x79, 0x2e,
	0x4c, 0x86, 0xaf, 0x54, 0x24, 0x75, 0x82, 0x95, 0x81, 0xb3, 0xea, 0x07, 0x8e, 0xfe, 0x63, 0xc1,
	0x3b, 0xeb, 0x77, 0x2c, 0x59, 0xd6, 0xfd, 0x74, 0xbf, 0x80, 0x26, 0x13, 0x3c, 0x53, 0x52, 0x0f,
	0x6a, 0xa7, 0xff, 0x41, 0xa5, 0xcd, 0xc6, 0x7b, 0x8c, 0x42, 0xac, 0x88, 0xa1, 0x0b, 0x70, 0x35,
	0xf0, 0x8a, 0x08, 0x1e, 0xec, 0x96, 0xdd, 0x4c, 0x13, 0x1e, 0x7b, 0x16, 0x39, 0x04, 0x62, 0x90,
	0xa7, 0x51, 0x78, 0x73, 0x31, 0x52, 0xa6, 0xbb, 0x1b, 0x47, 0xa1, 0x82, 0x1e, 0x47, 0x59, 0xa0,
	0xa4, 0xf4, 0x1c, 0x72, 0x00, 0x9e, 0x81, 0xf4, 0xcc, 0x5d, 0x7c, 0x7d, 0x2b, 0x52, 0xcf, 0xa5,
	0xbf, 0x5a, 0xb0, 0x87, 0x34, 0x71, 0x1e, 0xcc, 0x1c, 0x16, 0xbb, 0xc4, 0x5a, 0xee, 0x92, 0x6a,
	0x13, 0x34, 0x6a, 0x36, 0x41, 0x17, 0x60, 0x9c, 0xf0, 0x38, 0x1e, 0xc6, 0x91, 0x9c, 0xea, 0xed,
	0x64, 0xb3, 0x15, 0x84, 0x50, 0x70, 0x70, 0x7b, 0x6a, 0x6d, 0xda, 0xfd, 0x8e, 0x8e, 0xaf, 0xd6,
	0x29, 0xd3, 0x67, 0xb8, 0x89, 0x99, 0x9a, 0xcb, 0x69, 0xb1, 0xb1, 0x8c, 0x43, 0x3f, 0x81, 0x1d,
	0x64, 0xf7, 0x7c, 0x9e, 0xca, 0x0d, 0xc4, 0x08, 0x38, 0x83, 0x79, 0xae, 0xca, 0x3d, 0x8b, 0x36,
	0xfd, 0x0c, 0x3a, 0x38, 0xd1, 0x18, 0x31, 0x08, 0xf3, 0x48, 0xe9, 0xb8, 0x41, 0x98, 0x17, 0x1b,
	0x1e, 0x4d, 0x44, 0x70, 0x7b, 0x34, 0x34, 0x51, 0x34, 0xe9, 0x97, 0xd0, 0x29, 0xf3, 0xfc, 0xff,
	0x28, 0x44, 0x66, 0x2a, 0xd3, 0x05, 0xbb, 0x0c, 0x4d, 0x3a, 0x31, 0xf7, 0x9c, 0xcf, 0x2f, 0xe3,
	0x28, 0xd4, 0x2f, 0xcc, 0x6b, 0x1f, 0x8b, 0x52, 0x1c, 0xbb, 0x5e, 0x1c, 0x4a, 0x4d, 0x51, 0x58,
	0x60, 0x1d, 0x3d, 0xda, 0x81, 0xdd, 0xb2, 0x91, 0xd8, 0x5b, 0xfa, 0xbb, 0x05, 0xdb, 0x43, 0x1e,
	0x73, 0x19, 0x8a, 0xda, 0xb1, 0xfd, 0x78, 0xe5, 0x59, 0x2b, 0x36, 0xd6, 0x3a, 0x81, 0x95, 0x77,
	0x8f, 0x80, 0xf3, 0x84, 0x47, 0xb2, 0x68, 0xb0, 0xb6, 0xf1, 0x66, 0x26, 0xbe, 0xc7, 0xbe, 0x99,
	0x0d, 0x5d, 0x78, 0xcb, 0xb2, 0xdd, 0x9a, 0xb2, 0x1f, 0xc2, 0xce, 0xb7, 0xf8, 0xcb, 0xc4, 0xd0,
	0xa6, 0xae, 0xa2, 0xf2, 0xe9, 0xe7, 0xd0, 0xc6, 0x52, 0x4a, 0xf6, 0xc7, 0xb0, 0x53, 0x98, 0xa5,
	0x8a, 0xbb, 0x86, 0xa4, 0x01, 0x59, 0x75, 0x4a, 0xa7, 0xb0, 0x8b, 0x3a, 0xe1, 0x4f, 0x2c, 0xb8,
	0xe6, 0x39, 0xbe, 0x9a, 0xe3, 0x34, 0x7c, 0xa5, 0xf4, 0x25, 0x80, 0xa7, 0x8f, 0xb3, 0xbc, 0x38,
	0x35, 0x6d, 0x5d, 0x02, 0xf8, 0x32, 0x06, 0x4a, 0xe6, 0x42, 0xe6, 0xc5, 0x7b, 0x5b, 0xba, 0x98,
	0x05, 0xe9, 0xbd, 0xd9, 0x2c, 0x43, 0xff, 0x8f, 0xbb, 0xae, 0xf5, 0xf2, 0xae, 0x6b, 0xfd, 0x75,
	0xd7, 0xb5, 0x7e, 0xb9, 0xef, 0x6e, 0xbd, 0xbc, 0xef, 0x6e, 0xfd, 0x79, 0xdf, 0xdd, 0xba, 0x6c,
	0xea, 0x3f, 0x32, 0x9f, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xa1, 0xe0, 0xf9, 0x45, 0xd7, 0x08,
	0x00, 0x00,
}
