// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: match.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type S2C_QuickMatchStart_E_Err_QuickMatchStart int32

const (
	S2C_QuickMatchStart_E_Err_ S2C_QuickMatchStart_E_Err_QuickMatchStart = 0
	// 成功
	S2C_QuickMatchStart_E_Err_Success S2C_QuickMatchStart_E_Err_QuickMatchStart = 1
	// 分配房间失败
	S2C_QuickMatchStart_E_Err_Room S2C_QuickMatchStart_E_Err_QuickMatchStart = 2
	// 其它错误
	S2C_QuickMatchStart_E_Err_UnKnown S2C_QuickMatchStart_E_Err_QuickMatchStart = 3
)

var S2C_QuickMatchStart_E_Err_QuickMatchStart_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Success",
	2: "E_Err_Room",
	3: "E_Err_UnKnown",
}
var S2C_QuickMatchStart_E_Err_QuickMatchStart_value = map[string]int32{
	"E_Err_":        0,
	"E_Err_Success": 1,
	"E_Err_Room":    2,
	"E_Err_UnKnown": 3,
}

func (x S2C_QuickMatchStart_E_Err_QuickMatchStart) String() string {
	return proto.EnumName(S2C_QuickMatchStart_E_Err_QuickMatchStart_name, int32(x))
}
func (S2C_QuickMatchStart_E_Err_QuickMatchStart) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{4, 0}
}

type S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom int32

const (
	S2C_PlayerLeaveRoom_E_Err_ S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 0
	// /成功
	S2C_PlayerLeaveRoom_E_Err_Success S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 1
	// /失败,对局中
	S2C_PlayerLeaveRoom_E_Err_Playing S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 2
	// /失败,其它
	S2C_PlayerLeaveRoom_E_Err_UnKnown S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 3
)

var S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Success",
	2: "E_Err_Playing",
	3: "E_Err_UnKnown",
}
var S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_value = map[string]int32{
	"E_Err_":        0,
	"E_Err_Success": 1,
	"E_Err_Playing": 2,
	"E_Err_UnKnown": 3,
}

func (x S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom) String() string {
	return proto.EnumName(S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name, int32(x))
}
func (S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{6, 0}
}

// /牌
type Card struct {
	// /花色,1-黑桃(Spade),2-红桃(Heart),3-方块(Diamond),4-梅花(Club)
	Color int32 `protobuf:"varint,1,opt,name=Color,proto3" json:"Color,omitempty"`
	// /牌值,2-14
	Num int32 `protobuf:"varint,2,opt,name=Num,proto3" json:"Num,omitempty"`
}

func (m *Card) Reset()         { *m = Card{} }
func (m *Card) String() string { return proto.CompactTextString(m) }
func (*Card) ProtoMessage()    {}
func (*Card) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{0}
}
func (m *Card) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Card) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Card.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Card) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Card.Merge(dst, src)
}
func (m *Card) XXX_Size() int {
	return m.Size()
}
func (m *Card) XXX_DiscardUnknown() {
	xxx_messageInfo_Card.DiscardUnknown(m)
}

var xxx_messageInfo_Card proto.InternalMessageInfo

func (m *Card) GetColor() int32 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *Card) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

// / 玩家
type Player struct {
	// /用户Id
	UserId int64 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	// /玩家名
	NickName string `protobuf:"bytes,2,opt,name=NickName,proto3" json:"NickName,omitempty"`
	// /头像
	AvatarURL string `protobuf:"bytes,3,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// /在房间的位置
	Pos uint32 `protobuf:"varint,4,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /角色,0=普通玩家, 1=庄家，2=小盲, 3=大盲
	Role int32 `protobuf:"varint,5,opt,name=Role,proto3" json:"Role,omitempty"`
	// / 筹码
	Chip int64 `protobuf:"varint,6,opt,name=Chip,proto3" json:"Chip,omitempty"`
	// /已押注筹码
	BetChip int64 `protobuf:"varint,7,opt,name=BetChip,proto3" json:"BetChip,omitempty"`
	// /牌
	Cards []*Card `protobuf:"bytes,8,rep,name=Cards" json:"Cards,omitempty"`
	// /性别
	Sex string `protobuf:"bytes,9,opt,name=Sex,proto3" json:"Sex,omitempty"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{1}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(dst, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Player) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *Player) GetAvatarURL() string {
	if m != nil {
		return m.AvatarURL
	}
	return ""
}

func (m *Player) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *Player) GetRole() int32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *Player) GetChip() int64 {
	if m != nil {
		return m.Chip
	}
	return 0
}

func (m *Player) GetBetChip() int64 {
	if m != nil {
		return m.BetChip
	}
	return 0
}

func (m *Player) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *Player) GetSex() string {
	if m != nil {
		return m.Sex
	}
	return ""
}

// / 房间
type Room struct {
	// /房间号
	Id uint64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// /房间名
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// /房间玩家
	Players []*Player `protobuf:"bytes,3,rep,name=Players" json:"Players,omitempty"`
	// /房间奖池内的筹码
	Chip int64 `protobuf:"varint,4,opt,name=Chip,proto3" json:"Chip,omitempty"`
	// /当前最大加注
	MaxBet int64 `protobuf:"varint,5,opt,name=MaxBet,proto3" json:"MaxBet,omitempty"`
}

func (m *Room) Reset()         { *m = Room{} }
func (m *Room) String() string { return proto.CompactTextString(m) }
func (*Room) ProtoMessage()    {}
func (*Room) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{2}
}
func (m *Room) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Room) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Room.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Room) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Room.Merge(dst, src)
}
func (m *Room) XXX_Size() int {
	return m.Size()
}
func (m *Room) XXX_DiscardUnknown() {
	xxx_messageInfo_Room.DiscardUnknown(m)
}

var xxx_messageInfo_Room proto.InternalMessageInfo

func (m *Room) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Room) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Room) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *Room) GetChip() int64 {
	if m != nil {
		return m.Chip
	}
	return 0
}

func (m *Room) GetMaxBet() int64 {
	if m != nil {
		return m.MaxBet
	}
	return 0
}

// / 快速开始游戏请求
type C2S_QuickMatchStart struct {
}

func (m *C2S_QuickMatchStart) Reset()         { *m = C2S_QuickMatchStart{} }
func (m *C2S_QuickMatchStart) String() string { return proto.CompactTextString(m) }
func (*C2S_QuickMatchStart) ProtoMessage()    {}
func (*C2S_QuickMatchStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{3}
}
func (m *C2S_QuickMatchStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_QuickMatchStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_QuickMatchStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_QuickMatchStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_QuickMatchStart.Merge(dst, src)
}
func (m *C2S_QuickMatchStart) XXX_Size() int {
	return m.Size()
}
func (m *C2S_QuickMatchStart) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_QuickMatchStart.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_QuickMatchStart proto.InternalMessageInfo

// / 快速开始游戏回复
type S2C_QuickMatchStart struct {
	Err  S2C_QuickMatchStart_E_Err_QuickMatchStart `protobuf:"varint,1,opt,name=Err,proto3,enum=msg.S2C_QuickMatchStart_E_Err_QuickMatchStart" json:"Err,omitempty"`
	Room *Room                                     `protobuf:"bytes,2,opt,name=Room" json:"Room,omitempty"`
}

func (m *S2C_QuickMatchStart) Reset()         { *m = S2C_QuickMatchStart{} }
func (m *S2C_QuickMatchStart) String() string { return proto.CompactTextString(m) }
func (*S2C_QuickMatchStart) ProtoMessage()    {}
func (*S2C_QuickMatchStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{4}
}
func (m *S2C_QuickMatchStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_QuickMatchStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_QuickMatchStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_QuickMatchStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_QuickMatchStart.Merge(dst, src)
}
func (m *S2C_QuickMatchStart) XXX_Size() int {
	return m.Size()
}
func (m *S2C_QuickMatchStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_QuickMatchStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_QuickMatchStart proto.InternalMessageInfo

func (m *S2C_QuickMatchStart) GetErr() S2C_QuickMatchStart_E_Err_QuickMatchStart {
	if m != nil {
		return m.Err
	}
	return S2C_QuickMatchStart_E_Err_
}

func (m *S2C_QuickMatchStart) GetRoom() *Room {
	if m != nil {
		return m.Room
	}
	return nil
}

// / 玩家离开房间请求
type C2S_PlayerLeaveRoom struct {
}

func (m *C2S_PlayerLeaveRoom) Reset()         { *m = C2S_PlayerLeaveRoom{} }
func (m *C2S_PlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*C2S_PlayerLeaveRoom) ProtoMessage()    {}
func (*C2S_PlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{5}
}
func (m *C2S_PlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_PlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_PlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_PlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_PlayerLeaveRoom.Merge(dst, src)
}
func (m *C2S_PlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2S_PlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_PlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_PlayerLeaveRoom proto.InternalMessageInfo

// / 玩家离开房间回复
type S2C_PlayerLeaveRoom struct {
	Err S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom `protobuf:"varint,1,opt,name=Err,proto3,enum=msg.S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom" json:"Err,omitempty"`
}

func (m *S2C_PlayerLeaveRoom) Reset()         { *m = S2C_PlayerLeaveRoom{} }
func (m *S2C_PlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_PlayerLeaveRoom) ProtoMessage()    {}
func (*S2C_PlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{6}
}
func (m *S2C_PlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_PlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_PlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_PlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_PlayerLeaveRoom.Merge(dst, src)
}
func (m *S2C_PlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_PlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_PlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_PlayerLeaveRoom proto.InternalMessageInfo

func (m *S2C_PlayerLeaveRoom) GetErr() S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom {
	if m != nil {
		return m.Err
	}
	return S2C_PlayerLeaveRoom_E_Err_
}

// / 玩家加入房间
type S2C_UpdatePlayerJoinRoom struct {
	Players []*Player `protobuf:"bytes,1,rep,name=Players" json:"Players,omitempty"`
}

func (m *S2C_UpdatePlayerJoinRoom) Reset()         { *m = S2C_UpdatePlayerJoinRoom{} }
func (m *S2C_UpdatePlayerJoinRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_UpdatePlayerJoinRoom) ProtoMessage()    {}
func (*S2C_UpdatePlayerJoinRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{7}
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_UpdatePlayerJoinRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_UpdatePlayerJoinRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_UpdatePlayerJoinRoom.Merge(dst, src)
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_UpdatePlayerJoinRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_UpdatePlayerJoinRoom proto.InternalMessageInfo

func (m *S2C_UpdatePlayerJoinRoom) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// / 玩家离开房间
type S2C_UpdatePlayerLeaveRoom struct {
	// /离开的玩家的用户id
	UserId int64 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
}

func (m *S2C_UpdatePlayerLeaveRoom) Reset()         { *m = S2C_UpdatePlayerLeaveRoom{} }
func (m *S2C_UpdatePlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_UpdatePlayerLeaveRoom) ProtoMessage()    {}
func (*S2C_UpdatePlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{8}
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_UpdatePlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.Merge(dst, src)
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_UpdatePlayerLeaveRoom proto.InternalMessageInfo

func (m *S2C_UpdatePlayerLeaveRoom) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// / 开局
type S2C_GameStart struct {
	// /庄家位置
	Pos uint32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /牌
	Cards []*Card `protobuf:"bytes,2,rep,name=Cards" json:"Cards,omitempty"`
	// /初始小盲注
	SmallBlind int64 `protobuf:"varint,3,opt,name=SmallBlind,proto3" json:"SmallBlind,omitempty"`
}

func (m *S2C_GameStart) Reset()         { *m = S2C_GameStart{} }
func (m *S2C_GameStart) String() string { return proto.CompactTextString(m) }
func (*S2C_GameStart) ProtoMessage()    {}
func (*S2C_GameStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{9}
}
func (m *S2C_GameStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_GameStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_GameStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_GameStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_GameStart.Merge(dst, src)
}
func (m *S2C_GameStart) XXX_Size() int {
	return m.Size()
}
func (m *S2C_GameStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_GameStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_GameStart proto.InternalMessageInfo

func (m *S2C_GameStart) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *S2C_GameStart) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *S2C_GameStart) GetSmallBlind() int64 {
	if m != nil {
		return m.SmallBlind
	}
	return 0
}

// /当前轮到谁操作
type S2C_Turn struct {
	// /位置
	Pos uint32 `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /是否有自动操作,0-否,1-是
	Auto int32 `protobuf:"varint,2,opt,name=Auto,proto3" json:"Auto,omitempty"`
}

func (m *S2C_Turn) Reset()         { *m = S2C_Turn{} }
func (m *S2C_Turn) String() string { return proto.CompactTextString(m) }
func (*S2C_Turn) ProtoMessage()    {}
func (*S2C_Turn) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{10}
}
func (m *S2C_Turn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_Turn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_Turn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_Turn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_Turn.Merge(dst, src)
}
func (m *S2C_Turn) XXX_Size() int {
	return m.Size()
}
func (m *S2C_Turn) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_Turn.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_Turn proto.InternalMessageInfo

func (m *S2C_Turn) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *S2C_Turn) GetAuto() int32 {
	if m != nil {
		return m.Auto
	}
	return 0
}

// /玩家操作
type C2S_TurnAction struct {
	// /操作,1-让牌,2-弃牌,3-跟注,4-加注,5-Allin
	Act int32 `protobuf:"varint,1,opt,name=Act,proto3" json:"Act,omitempty"`
	// /加注值
	Bet int64 `protobuf:"varint,2,opt,name=Bet,proto3" json:"Bet,omitempty"`
}

func (m *C2S_TurnAction) Reset()         { *m = C2S_TurnAction{} }
func (m *C2S_TurnAction) String() string { return proto.CompactTextString(m) }
func (*C2S_TurnAction) ProtoMessage()    {}
func (*C2S_TurnAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{11}
}
func (m *C2S_TurnAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_TurnAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_TurnAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_TurnAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_TurnAction.Merge(dst, src)
}
func (m *C2S_TurnAction) XXX_Size() int {
	return m.Size()
}
func (m *C2S_TurnAction) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_TurnAction.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_TurnAction proto.InternalMessageInfo

func (m *C2S_TurnAction) GetAct() int32 {
	if m != nil {
		return m.Act
	}
	return 0
}

func (m *C2S_TurnAction) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

// /玩家操作回复,实际操作
type S2C_TurnAction struct {
	// /1-让牌,2-弃牌,3-跟注,4-加注,5-Allin
	Act int32 `protobuf:"varint,1,opt,name=Act,proto3" json:"Act,omitempty"`
	// /跟注值
	Bet int64 `protobuf:"varint,2,opt,name=Bet,proto3" json:"Bet,omitempty"`
	// /玩家位置
	Pos int32 `protobuf:"varint,3,opt,name=pos,proto3" json:"pos,omitempty"`
}

func (m *S2C_TurnAction) Reset()         { *m = S2C_TurnAction{} }
func (m *S2C_TurnAction) String() string { return proto.CompactTextString(m) }
func (*S2C_TurnAction) ProtoMessage()    {}
func (*S2C_TurnAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{12}
}
func (m *S2C_TurnAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_TurnAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_TurnAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_TurnAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_TurnAction.Merge(dst, src)
}
func (m *S2C_TurnAction) XXX_Size() int {
	return m.Size()
}
func (m *S2C_TurnAction) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_TurnAction.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_TurnAction proto.InternalMessageInfo

func (m *S2C_TurnAction) GetAct() int32 {
	if m != nil {
		return m.Act
	}
	return 0
}

func (m *S2C_TurnAction) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *S2C_TurnAction) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// /发公共牌
type S2C_PublicCard struct {
	// /公共牌
	Cards []*Card `protobuf:"bytes,1,rep,name=Cards" json:"Cards,omitempty"`
}

func (m *S2C_PublicCard) Reset()         { *m = S2C_PublicCard{} }
func (m *S2C_PublicCard) String() string { return proto.CompactTextString(m) }
func (*S2C_PublicCard) ProtoMessage()    {}
func (*S2C_PublicCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{13}
}
func (m *S2C_PublicCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_PublicCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_PublicCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_PublicCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_PublicCard.Merge(dst, src)
}
func (m *S2C_PublicCard) XXX_Size() int {
	return m.Size()
}
func (m *S2C_PublicCard) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_PublicCard.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_PublicCard proto.InternalMessageInfo

func (m *S2C_PublicCard) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

// /勾选自动操作
type C2S_AutoAction struct {
	// /0-无勾选,1-让牌,2-弃牌,3-跟注,4-跟任何注
	Act int32 `protobuf:"varint,1,opt,name=Act,proto3" json:"Act,omitempty"`
}

func (m *C2S_AutoAction) Reset()         { *m = C2S_AutoAction{} }
func (m *C2S_AutoAction) String() string { return proto.CompactTextString(m) }
func (*C2S_AutoAction) ProtoMessage()    {}
func (*C2S_AutoAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{14}
}
func (m *C2S_AutoAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_AutoAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_AutoAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_AutoAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_AutoAction.Merge(dst, src)
}
func (m *C2S_AutoAction) XXX_Size() int {
	return m.Size()
}
func (m *C2S_AutoAction) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_AutoAction.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_AutoAction proto.InternalMessageInfo

func (m *C2S_AutoAction) GetAct() int32 {
	if m != nil {
		return m.Act
	}
	return 0
}

// /当前最大牌型
type BestCombo struct {
	Cards []*Card `protobuf:"bytes,1,rep,name=Cards" json:"Cards,omitempty"`
	// /1-皇家同花顺,2-同花顺,3-四条(金刚),4-葫芦,5-通话
	// /6-顺子,7-三条,8-两队,9-对子,10-高牌
	Type int32 `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *BestCombo) Reset()         { *m = BestCombo{} }
func (m *BestCombo) String() string { return proto.CompactTextString(m) }
func (*BestCombo) ProtoMessage()    {}
func (*BestCombo) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{15}
}
func (m *BestCombo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BestCombo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BestCombo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BestCombo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BestCombo.Merge(dst, src)
}
func (m *BestCombo) XXX_Size() int {
	return m.Size()
}
func (m *BestCombo) XXX_DiscardUnknown() {
	xxx_messageInfo_BestCombo.DiscardUnknown(m)
}

var xxx_messageInfo_BestCombo proto.InternalMessageInfo

func (m *BestCombo) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *BestCombo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// /游戏结束
type S2C_GameOver struct {
}

func (m *S2C_GameOver) Reset()         { *m = S2C_GameOver{} }
func (m *S2C_GameOver) String() string { return proto.CompactTextString(m) }
func (*S2C_GameOver) ProtoMessage()    {}
func (*S2C_GameOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_4e0adfdf7c44b1c6, []int{16}
}
func (m *S2C_GameOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_GameOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_GameOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_GameOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_GameOver.Merge(dst, src)
}
func (m *S2C_GameOver) XXX_Size() int {
	return m.Size()
}
func (m *S2C_GameOver) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_GameOver.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_GameOver proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Card)(nil), "msg.Card")
	proto.RegisterType((*Player)(nil), "msg.Player")
	proto.RegisterType((*Room)(nil), "msg.Room")
	proto.RegisterType((*C2S_QuickMatchStart)(nil), "msg.C2S_QuickMatchStart")
	proto.RegisterType((*S2C_QuickMatchStart)(nil), "msg.S2C_QuickMatchStart")
	proto.RegisterType((*C2S_PlayerLeaveRoom)(nil), "msg.C2S_PlayerLeaveRoom")
	proto.RegisterType((*S2C_PlayerLeaveRoom)(nil), "msg.S2C_PlayerLeaveRoom")
	proto.RegisterType((*S2C_UpdatePlayerJoinRoom)(nil), "msg.S2C_UpdatePlayerJoinRoom")
	proto.RegisterType((*S2C_UpdatePlayerLeaveRoom)(nil), "msg.S2C_UpdatePlayerLeaveRoom")
	proto.RegisterType((*S2C_GameStart)(nil), "msg.S2C_GameStart")
	proto.RegisterType((*S2C_Turn)(nil), "msg.S2C_Turn")
	proto.RegisterType((*C2S_TurnAction)(nil), "msg.C2S_TurnAction")
	proto.RegisterType((*S2C_TurnAction)(nil), "msg.S2C_TurnAction")
	proto.RegisterType((*S2C_PublicCard)(nil), "msg.S2C_PublicCard")
	proto.RegisterType((*C2S_AutoAction)(nil), "msg.C2S_AutoAction")
	proto.RegisterType((*BestCombo)(nil), "msg.BestCombo")
	proto.RegisterType((*S2C_GameOver)(nil), "msg.S2C_GameOver")
	proto.RegisterEnum("msg.S2C_QuickMatchStart_E_Err_QuickMatchStart", S2C_QuickMatchStart_E_Err_QuickMatchStart_name, S2C_QuickMatchStart_E_Err_QuickMatchStart_value)
	proto.RegisterEnum("msg.S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom", S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name, S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_value)
}
func (m *Card) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Card) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Color != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Color))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.UserId))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.AvatarURL) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.AvatarURL)))
		i += copy(dAtA[i:], m.AvatarURL)
	}
	if m.Pos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if m.Role != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Role))
	}
	if m.Chip != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Chip))
	}
	if m.BetChip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.BetChip))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Sex) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Sex)))
		i += copy(dAtA[i:], m.Sex)
	}
	return i, nil
}

func (m *Room) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Room) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Chip != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Chip))
	}
	if m.MaxBet != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.MaxBet))
	}
	return i, nil
}

func (m *C2S_QuickMatchStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_QuickMatchStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *S2C_QuickMatchStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_QuickMatchStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Err))
	}
	if m.Room != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Room.Size()))
		n1, err := m.Room.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *C2S_PlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_PlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *S2C_PlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_PlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Err))
	}
	return i, nil
}

func (m *S2C_UpdatePlayerJoinRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_UpdatePlayerJoinRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *S2C_UpdatePlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_UpdatePlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *S2C_GameStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_GameStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SmallBlind != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.SmallBlind))
	}
	return i, nil
}

func (m *S2C_Turn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_Turn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if m.Auto != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Auto))
	}
	return i, nil
}

func (m *C2S_TurnAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_TurnAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Act != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Act))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Bet))
	}
	return i, nil
}

func (m *S2C_TurnAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_TurnAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Act != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Act))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Bet))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	return i, nil
}

func (m *S2C_PublicCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_PublicCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C2S_AutoAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_AutoAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Act != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Act))
	}
	return i, nil
}

func (m *BestCombo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BestCombo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *S2C_GameOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_GameOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintMatch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Card) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != 0 {
		n += 1 + sovMatch(uint64(m.Color))
	}
	if m.Num != 0 {
		n += 1 + sovMatch(uint64(m.Num))
	}
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMatch(uint64(m.UserId))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if m.Role != 0 {
		n += 1 + sovMatch(uint64(m.Role))
	}
	if m.Chip != 0 {
		n += 1 + sovMatch(uint64(m.Chip))
	}
	if m.BetChip != 0 {
		n += 1 + sovMatch(uint64(m.BetChip))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	l = len(m.Sex)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *Room) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMatch(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.Chip != 0 {
		n += 1 + sovMatch(uint64(m.Chip))
	}
	if m.MaxBet != 0 {
		n += 1 + sovMatch(uint64(m.MaxBet))
	}
	return n
}

func (m *C2S_QuickMatchStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2C_QuickMatchStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != 0 {
		n += 1 + sovMatch(uint64(m.Err))
	}
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *C2S_PlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2C_PlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != 0 {
		n += 1 + sovMatch(uint64(m.Err))
	}
	return n
}

func (m *S2C_UpdatePlayerJoinRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	return n
}

func (m *S2C_UpdatePlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMatch(uint64(m.UserId))
	}
	return n
}

func (m *S2C_GameStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.SmallBlind != 0 {
		n += 1 + sovMatch(uint64(m.SmallBlind))
	}
	return n
}

func (m *S2C_Turn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if m.Auto != 0 {
		n += 1 + sovMatch(uint64(m.Auto))
	}
	return n
}

func (m *C2S_TurnAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Act != 0 {
		n += 1 + sovMatch(uint64(m.Act))
	}
	if m.Bet != 0 {
		n += 1 + sovMatch(uint64(m.Bet))
	}
	return n
}

func (m *S2C_TurnAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Act != 0 {
		n += 1 + sovMatch(uint64(m.Act))
	}
	if m.Bet != 0 {
		n += 1 + sovMatch(uint64(m.Bet))
	}
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	return n
}

func (m *S2C_PublicCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	return n
}

func (m *C2S_AutoAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Act != 0 {
		n += 1 + sovMatch(uint64(m.Act))
	}
	return n
}

func (m *BestCombo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovMatch(uint64(m.Type))
	}
	return n
}

func (m *S2C_GameOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovMatch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMatch(x uint64) (n int) {
	return sovMatch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Card) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetChip", wireType)
			}
			m.BetChip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetChip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Room) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Room: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Room: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBet", wireType)
			}
			m.MaxBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_QuickMatchStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_QuickMatchStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_QuickMatchStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_QuickMatchStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_QuickMatchStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_QuickMatchStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (S2C_QuickMatchStart_E_Err_QuickMatchStart(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &Room{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_PlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_PlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_PlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_PlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_PlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_PlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_UpdatePlayerJoinRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_UpdatePlayerJoinRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_UpdatePlayerJoinRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_UpdatePlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_UpdatePlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_UpdatePlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_GameStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_GameStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_GameStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallBlind", wireType)
			}
			m.SmallBlind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmallBlind |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_Turn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_Turn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_Turn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			m.Auto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Auto |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_TurnAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_TurnAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_TurnAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			m.Act = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Act |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_TurnAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_TurnAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_TurnAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			m.Act = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Act |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_PublicCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_PublicCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_PublicCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_AutoAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_AutoAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_AutoAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			m.Act = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Act |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BestCombo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BestCombo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BestCombo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_GameOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_GameOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_GameOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMatch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMatch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMatch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMatch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMatch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("match.proto", fileDescriptor_match_4e0adfdf7c44b1c6) }

var fileDescriptor_match_4e0adfdf7c44b1c6 = []byte{
	// 659 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0x8e, 0xe3, 0x24, 0x6d, 0xa6, 0x7f, 0xa3, 0xfc, 0x5b, 0x5a, 0x19, 0x04, 0xa6, 0x5a, 0x09,
	0xa9, 0xa7, 0x08, 0x52, 0x1e, 0xa0, 0x49, 0x54, 0x50, 0xa1, 0x2d, 0x65, 0xd3, 0x1c, 0x90, 0x90,
	0x2a, 0xc7, 0x59, 0xb5, 0x56, 0x6d, 0x6f, 0x64, 0x6f, 0x4a, 0x7b, 0xe0, 0x1d, 0x78, 0x19, 0xde,
	0x81, 0x63, 0xb9, 0x71, 0x84, 0xf6, 0x45, 0xd0, 0xcc, 0xda, 0x49, 0x64, 0x25, 0x2a, 0xb7, 0x6f,
	0x3f, 0xef, 0xcc, 0x37, 0xdf, 0x8c, 0x67, 0x61, 0x2d, 0xf2, 0xb4, 0x7f, 0xd1, 0x1a, 0x27, 0x4a,
	0x2b, 0x66, 0x47, 0xe9, 0x39, 0x6f, 0x41, 0xa5, 0xe7, 0x25, 0x23, 0xf6, 0x08, 0xaa, 0x3d, 0x15,
	0xaa, 0xc4, 0xb1, 0xb6, 0xad, 0x9d, 0xaa, 0x30, 0x07, 0xd6, 0x04, 0xfb, 0x78, 0x12, 0x39, 0x65,
	0xe2, 0x10, 0xf2, 0x3f, 0x16, 0xd4, 0x4e, 0x42, 0xef, 0x46, 0x26, 0x6c, 0x0b, 0x6a, 0x83, 0x54,
	0x26, 0x07, 0x23, 0x8a, 0xb1, 0x45, 0x76, 0x62, 0x4f, 0x60, 0xf5, 0x38, 0xf0, 0x2f, 0x8f, 0xbd,
	0x48, 0x52, 0x64, 0x5d, 0x4c, 0xcf, 0xec, 0x29, 0xd4, 0x3b, 0x57, 0x9e, 0xf6, 0x92, 0x81, 0x38,
	0x74, 0x6c, 0xfa, 0x38, 0x23, 0x50, 0xee, 0x44, 0xa5, 0x4e, 0x65, 0xdb, 0xda, 0x59, 0x17, 0x08,
	0x19, 0x83, 0x8a, 0x50, 0xa1, 0x74, 0xaa, 0x54, 0x01, 0x61, 0xe4, 0x7a, 0x17, 0xc1, 0xd8, 0xa9,
	0x91, 0x2a, 0x61, 0xe6, 0xc0, 0x4a, 0x57, 0x6a, 0xa2, 0x57, 0x88, 0xce, 0x8f, 0xec, 0x39, 0x54,
	0xd1, 0x60, 0xea, 0xac, 0x6e, 0xdb, 0x3b, 0x6b, 0xed, 0x7a, 0x2b, 0x4a, 0xcf, 0x5b, 0xc8, 0x08,
	0xc3, 0xa3, 0x68, 0x5f, 0x5e, 0x3b, 0x75, 0x2a, 0x06, 0x21, 0xff, 0x8a, 0xa2, 0x2a, 0x62, 0x0d,
	0x28, 0x67, 0xe6, 0x2a, 0xa2, 0x7c, 0x30, 0x42, 0xe1, 0x39, 0x53, 0x84, 0xd9, 0x0b, 0x58, 0x31,
	0xed, 0x48, 0x1d, 0x9b, 0x04, 0xd6, 0x48, 0xc0, 0x70, 0x22, 0xff, 0x36, 0xad, 0xb9, 0x32, 0x57,
	0xf3, 0x16, 0xd4, 0x8e, 0xbc, 0xeb, 0xae, 0xd4, 0xe4, 0xce, 0x16, 0xd9, 0x89, 0x6f, 0xc2, 0x46,
	0xaf, 0xdd, 0x3f, 0xfb, 0x38, 0x09, 0xfc, 0xcb, 0x23, 0x9c, 0x57, 0x5f, 0x7b, 0x89, 0xe6, 0x3f,
	0x2d, 0xd8, 0xe8, 0xb7, 0x7b, 0x45, 0x9e, 0xed, 0x81, 0xbd, 0x9f, 0x98, 0xb9, 0x35, 0xda, 0x2d,
	0x52, 0x5f, 0x70, 0xad, 0xb5, 0x7f, 0xb6, 0x9f, 0x24, 0x45, 0x56, 0x60, 0x28, 0x7b, 0x66, 0xfc,
	0x92, 0xaf, 0xbc, 0x43, 0x48, 0x08, 0xa2, 0xf9, 0x27, 0xd8, 0x5c, 0x18, 0xcc, 0x00, 0x6a, 0xe6,
	0x43, 0xb3, 0xc4, 0xfe, 0x87, 0x75, 0x83, 0xfb, 0x13, 0xdf, 0x97, 0x69, 0xda, 0xb4, 0x58, 0x03,
	0xc0, 0x50, 0x98, 0xa5, 0x59, 0x9e, 0x5d, 0x19, 0xc4, 0xef, 0x63, 0xf5, 0x25, 0x6e, 0xda, 0xb9,
	0x55, 0xd3, 0xa5, 0x43, 0xe9, 0x5d, 0x49, 0x52, 0xfc, 0x9e, 0x59, 0x2d, 0xf0, 0xcb, 0xac, 0x16,
	0xae, 0x65, 0x56, 0x0b, 0x2c, 0x59, 0xe5, 0x9f, 0x73, 0x2f, 0xc5, 0xd4, 0x0f, 0x78, 0x99, 0x52,
	0x18, 0x17, 0xc4, 0xe7, 0x8b, 0xed, 0x74, 0xc0, 0xc1, 0x7a, 0x06, 0xe3, 0x91, 0xa7, 0xa5, 0x51,
	0x78, 0xa7, 0x82, 0x98, 0x04, 0xe6, 0x7e, 0x14, 0x6b, 0xf9, 0x8f, 0xc2, 0x77, 0xe1, 0x71, 0x31,
	0xc5, 0xac, 0xc8, 0x25, 0x1b, 0xc7, 0x87, 0xb0, 0x8e, 0x41, 0x6f, 0xbd, 0x48, 0x9a, 0xc9, 0x64,
	0x8b, 0x64, 0xcd, 0x16, 0x69, 0xba, 0x06, 0xe5, 0x25, 0x6b, 0xe0, 0x02, 0xf4, 0x23, 0x2f, 0x0c,
	0xbb, 0x61, 0x10, 0x8f, 0x68, 0x35, 0x6d, 0x31, 0xc7, 0xf0, 0x97, 0xb0, 0x8a, 0x1a, 0xa7, 0x93,
	0x24, 0x5e, 0x90, 0x9e, 0x41, 0xa5, 0x33, 0xd1, 0x2a, 0x7b, 0x29, 0x08, 0xf3, 0xd7, 0xd0, 0xc0,
	0xe1, 0x62, 0x44, 0xc7, 0xd7, 0x81, 0xa2, 0xb8, 0x8e, 0xaf, 0xb3, 0x27, 0x06, 0x21, 0x32, 0xb8,
	0x00, 0x65, 0x92, 0x43, 0xc8, 0xdf, 0x40, 0x23, 0xd7, 0xf9, 0xf7, 0x28, 0x64, 0xc6, 0x2a, 0xa5,
	0xb2, 0xab, 0x02, 0x21, 0x7f, 0x65, 0xf2, 0x9c, 0x4c, 0x86, 0x61, 0xe0, 0xd3, 0x13, 0x37, 0x6d,
	0x81, 0xb5, 0xb8, 0x05, 0x9c, 0x9b, 0x82, 0xb1, 0xf8, 0x65, 0xd2, 0x7c, 0x0f, 0xea, 0x5d, 0x99,
	0xea, 0x9e, 0x8a, 0x86, 0xea, 0xc1, 0x8c, 0xd8, 0x96, 0xd3, 0x9b, 0xb1, 0xcc, 0xdb, 0x82, 0x98,
	0x37, 0xe0, 0xbf, 0x7c, 0x58, 0x1f, 0xae, 0x64, 0xd2, 0x75, 0x7e, 0xdc, 0xb9, 0xd6, 0xed, 0x9d,
	0x6b, 0xfd, 0xbe, 0x73, 0xad, 0x6f, 0xf7, 0x6e, 0xe9, 0xf6, 0xde, 0x2d, 0xfd, 0xba, 0x77, 0x4b,
	0xc3, 0x1a, 0xbd, 0xd3, 0xbb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x23, 0x87, 0x8c, 0x1c, 0xb6,
	0x05, 0x00, 0x00,
}
