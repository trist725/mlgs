// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: match.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type S2C_QuickMatchStart_E_Err_QuickMatchStart int32

const (
	S2C_QuickMatchStart_E_Err_ S2C_QuickMatchStart_E_Err_QuickMatchStart = 0
	// 成功
	S2C_QuickMatchStart_E_Err_Success S2C_QuickMatchStart_E_Err_QuickMatchStart = 1
	// 分配房间失败
	S2C_QuickMatchStart_E_Err_Room S2C_QuickMatchStart_E_Err_QuickMatchStart = 2
	// 其它错误
	S2C_QuickMatchStart_E_Err_UnKnown S2C_QuickMatchStart_E_Err_QuickMatchStart = 3
)

var S2C_QuickMatchStart_E_Err_QuickMatchStart_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Success",
	2: "E_Err_Room",
	3: "E_Err_UnKnown",
}
var S2C_QuickMatchStart_E_Err_QuickMatchStart_value = map[string]int32{
	"E_Err_":        0,
	"E_Err_Success": 1,
	"E_Err_Room":    2,
	"E_Err_UnKnown": 3,
}

func (x S2C_QuickMatchStart_E_Err_QuickMatchStart) String() string {
	return proto.EnumName(S2C_QuickMatchStart_E_Err_QuickMatchStart_name, int32(x))
}
func (S2C_QuickMatchStart_E_Err_QuickMatchStart) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{3, 0}
}

type S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom int32

const (
	S2C_PlayerLeaveRoom_E_Err_ S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 0
	// /成功
	S2C_PlayerLeaveRoom_E_Err_Success S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 1
	// /失败,其它
	S2C_PlayerLeaveRoom_E_Err_UnKnown S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom = 2
)

var S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name = map[int32]string{
	0: "E_Err_",
	1: "E_Err_Success",
	2: "E_Err_UnKnown",
}
var S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_value = map[string]int32{
	"E_Err_":        0,
	"E_Err_Success": 1,
	"E_Err_UnKnown": 2,
}

func (x S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom) String() string {
	return proto.EnumName(S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name, int32(x))
}
func (S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{5, 0}
}

// / 玩家
type Player struct {
	// /用户Id
	UserId int64 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	// /玩家名
	NickName string `protobuf:"bytes,2,opt,name=NickName,proto3" json:"NickName,omitempty"`
	// /头像
	AvatarURL string `protobuf:"bytes,3,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// /在房间的位置
	Pos uint32 `protobuf:"varint,4,opt,name=Pos,proto3" json:"Pos,omitempty"`
	// /角色,1=庄家，2=大盲, 3=小盲
	Role int32 `protobuf:"varint,5,opt,name=Role,proto3" json:"Role,omitempty"`
	// / 筹码
	Chip int64 `protobuf:"varint,6,opt,name=Chip,proto3" json:"Chip,omitempty"`
	// /已押注筹码
	BetChip int64 `protobuf:"varint,7,opt,name=BetChip,proto3" json:"BetChip,omitempty"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{0}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(dst, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Player) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *Player) GetAvatarURL() string {
	if m != nil {
		return m.AvatarURL
	}
	return ""
}

func (m *Player) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *Player) GetRole() int32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *Player) GetChip() int64 {
	if m != nil {
		return m.Chip
	}
	return 0
}

func (m *Player) GetBetChip() int64 {
	if m != nil {
		return m.BetChip
	}
	return 0
}

// / 房间
type Room struct {
	// /房间号
	Id uint64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// /房间名
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// /房间玩家
	Players []*Player `protobuf:"bytes,3,rep,name=Players" json:"Players,omitempty"`
	// /房间奖池内的筹码
	Chip int64 `protobuf:"varint,4,opt,name=Chip,proto3" json:"Chip,omitempty"`
	// /当前最大加注
	MaxBet int64 `protobuf:"varint,5,opt,name=MaxBet,proto3" json:"MaxBet,omitempty"`
}

func (m *Room) Reset()         { *m = Room{} }
func (m *Room) String() string { return proto.CompactTextString(m) }
func (*Room) ProtoMessage()    {}
func (*Room) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{1}
}
func (m *Room) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Room) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Room.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Room) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Room.Merge(dst, src)
}
func (m *Room) XXX_Size() int {
	return m.Size()
}
func (m *Room) XXX_DiscardUnknown() {
	xxx_messageInfo_Room.DiscardUnknown(m)
}

var xxx_messageInfo_Room proto.InternalMessageInfo

func (m *Room) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Room) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Room) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *Room) GetChip() int64 {
	if m != nil {
		return m.Chip
	}
	return 0
}

func (m *Room) GetMaxBet() int64 {
	if m != nil {
		return m.MaxBet
	}
	return 0
}

// / 快速开始游戏请求
type C2S_QuickMatchStart struct {
}

func (m *C2S_QuickMatchStart) Reset()         { *m = C2S_QuickMatchStart{} }
func (m *C2S_QuickMatchStart) String() string { return proto.CompactTextString(m) }
func (*C2S_QuickMatchStart) ProtoMessage()    {}
func (*C2S_QuickMatchStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{2}
}
func (m *C2S_QuickMatchStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_QuickMatchStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_QuickMatchStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_QuickMatchStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_QuickMatchStart.Merge(dst, src)
}
func (m *C2S_QuickMatchStart) XXX_Size() int {
	return m.Size()
}
func (m *C2S_QuickMatchStart) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_QuickMatchStart.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_QuickMatchStart proto.InternalMessageInfo

// / 快速开始游戏回复
type S2C_QuickMatchStart struct {
	Err  S2C_QuickMatchStart_E_Err_QuickMatchStart `protobuf:"varint,1,opt,name=Err,proto3,enum=msg.S2C_QuickMatchStart_E_Err_QuickMatchStart" json:"Err,omitempty"`
	Room *Room                                     `protobuf:"bytes,2,opt,name=Room" json:"Room,omitempty"`
}

func (m *S2C_QuickMatchStart) Reset()         { *m = S2C_QuickMatchStart{} }
func (m *S2C_QuickMatchStart) String() string { return proto.CompactTextString(m) }
func (*S2C_QuickMatchStart) ProtoMessage()    {}
func (*S2C_QuickMatchStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{3}
}
func (m *S2C_QuickMatchStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_QuickMatchStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_QuickMatchStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_QuickMatchStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_QuickMatchStart.Merge(dst, src)
}
func (m *S2C_QuickMatchStart) XXX_Size() int {
	return m.Size()
}
func (m *S2C_QuickMatchStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_QuickMatchStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_QuickMatchStart proto.InternalMessageInfo

func (m *S2C_QuickMatchStart) GetErr() S2C_QuickMatchStart_E_Err_QuickMatchStart {
	if m != nil {
		return m.Err
	}
	return S2C_QuickMatchStart_E_Err_
}

func (m *S2C_QuickMatchStart) GetRoom() *Room {
	if m != nil {
		return m.Room
	}
	return nil
}

// / 玩家离开房间请求
type C2S_PlayerLeaveRoom struct {
}

func (m *C2S_PlayerLeaveRoom) Reset()         { *m = C2S_PlayerLeaveRoom{} }
func (m *C2S_PlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*C2S_PlayerLeaveRoom) ProtoMessage()    {}
func (*C2S_PlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{4}
}
func (m *C2S_PlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_PlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_PlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *C2S_PlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_PlayerLeaveRoom.Merge(dst, src)
}
func (m *C2S_PlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2S_PlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_PlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_PlayerLeaveRoom proto.InternalMessageInfo

// / 玩家离开房间回复
type S2C_PlayerLeaveRoom struct {
	Err S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom `protobuf:"varint,1,opt,name=Err,proto3,enum=msg.S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom" json:"Err,omitempty"`
}

func (m *S2C_PlayerLeaveRoom) Reset()         { *m = S2C_PlayerLeaveRoom{} }
func (m *S2C_PlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_PlayerLeaveRoom) ProtoMessage()    {}
func (*S2C_PlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{5}
}
func (m *S2C_PlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_PlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_PlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_PlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_PlayerLeaveRoom.Merge(dst, src)
}
func (m *S2C_PlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_PlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_PlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_PlayerLeaveRoom proto.InternalMessageInfo

func (m *S2C_PlayerLeaveRoom) GetErr() S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom {
	if m != nil {
		return m.Err
	}
	return S2C_PlayerLeaveRoom_E_Err_
}

// / 玩家加入房间
type S2C_UpdatePlayerJoinRoom struct {
	Players []*Player `protobuf:"bytes,1,rep,name=Players" json:"Players,omitempty"`
}

func (m *S2C_UpdatePlayerJoinRoom) Reset()         { *m = S2C_UpdatePlayerJoinRoom{} }
func (m *S2C_UpdatePlayerJoinRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_UpdatePlayerJoinRoom) ProtoMessage()    {}
func (*S2C_UpdatePlayerJoinRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{6}
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_UpdatePlayerJoinRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_UpdatePlayerJoinRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_UpdatePlayerJoinRoom.Merge(dst, src)
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_UpdatePlayerJoinRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_UpdatePlayerJoinRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_UpdatePlayerJoinRoom proto.InternalMessageInfo

func (m *S2C_UpdatePlayerJoinRoom) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// / 玩家离开房间
type S2C_UpdatePlayerLeaveRoom struct {
	// /离开的玩家的用户id
	UserIds []int64 `protobuf:"varint,1,rep,packed,name=UserIds" json:"UserIds,omitempty"`
}

func (m *S2C_UpdatePlayerLeaveRoom) Reset()         { *m = S2C_UpdatePlayerLeaveRoom{} }
func (m *S2C_UpdatePlayerLeaveRoom) String() string { return proto.CompactTextString(m) }
func (*S2C_UpdatePlayerLeaveRoom) ProtoMessage()    {}
func (*S2C_UpdatePlayerLeaveRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_match_e89479ba4cb4f4b2, []int{7}
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *S2C_UpdatePlayerLeaveRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.Merge(dst, src)
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2C_UpdatePlayerLeaveRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_UpdatePlayerLeaveRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_UpdatePlayerLeaveRoom proto.InternalMessageInfo

func (m *S2C_UpdatePlayerLeaveRoom) GetUserIds() []int64 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func init() {
	proto.RegisterType((*Player)(nil), "msg.Player")
	proto.RegisterType((*Room)(nil), "msg.Room")
	proto.RegisterType((*C2S_QuickMatchStart)(nil), "msg.C2S_QuickMatchStart")
	proto.RegisterType((*S2C_QuickMatchStart)(nil), "msg.S2C_QuickMatchStart")
	proto.RegisterType((*C2S_PlayerLeaveRoom)(nil), "msg.C2S_PlayerLeaveRoom")
	proto.RegisterType((*S2C_PlayerLeaveRoom)(nil), "msg.S2C_PlayerLeaveRoom")
	proto.RegisterType((*S2C_UpdatePlayerJoinRoom)(nil), "msg.S2C_UpdatePlayerJoinRoom")
	proto.RegisterType((*S2C_UpdatePlayerLeaveRoom)(nil), "msg.S2C_UpdatePlayerLeaveRoom")
	proto.RegisterEnum("msg.S2C_QuickMatchStart_E_Err_QuickMatchStart", S2C_QuickMatchStart_E_Err_QuickMatchStart_name, S2C_QuickMatchStart_E_Err_QuickMatchStart_value)
	proto.RegisterEnum("msg.S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom", S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_name, S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom_value)
}
func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.UserId))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.AvatarURL) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.AvatarURL)))
		i += copy(dAtA[i:], m.AvatarURL)
	}
	if m.Pos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Pos))
	}
	if m.Role != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Role))
	}
	if m.Chip != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Chip))
	}
	if m.BetChip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.BetChip))
	}
	return i, nil
}

func (m *Room) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Room) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Chip != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Chip))
	}
	if m.MaxBet != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.MaxBet))
	}
	return i, nil
}

func (m *C2S_QuickMatchStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_QuickMatchStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *S2C_QuickMatchStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_QuickMatchStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Err))
	}
	if m.Room != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Room.Size()))
		n1, err := m.Room.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *C2S_PlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_PlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *S2C_PlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_PlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMatch(dAtA, i, uint64(m.Err))
	}
	return i, nil
}

func (m *S2C_UpdatePlayerJoinRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_UpdatePlayerJoinRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *S2C_UpdatePlayerLeaveRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_UpdatePlayerLeaveRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA3 := make([]byte, len(m.UserIds)*10)
		var j2 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintMatch(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func encodeVarintMatch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMatch(uint64(m.UserId))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	if m.Pos != 0 {
		n += 1 + sovMatch(uint64(m.Pos))
	}
	if m.Role != 0 {
		n += 1 + sovMatch(uint64(m.Role))
	}
	if m.Chip != 0 {
		n += 1 + sovMatch(uint64(m.Chip))
	}
	if m.BetChip != 0 {
		n += 1 + sovMatch(uint64(m.BetChip))
	}
	return n
}

func (m *Room) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMatch(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMatch(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.Chip != 0 {
		n += 1 + sovMatch(uint64(m.Chip))
	}
	if m.MaxBet != 0 {
		n += 1 + sovMatch(uint64(m.MaxBet))
	}
	return n
}

func (m *C2S_QuickMatchStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2C_QuickMatchStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != 0 {
		n += 1 + sovMatch(uint64(m.Err))
	}
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovMatch(uint64(l))
	}
	return n
}

func (m *C2S_PlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2C_PlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != 0 {
		n += 1 + sovMatch(uint64(m.Err))
	}
	return n
}

func (m *S2C_UpdatePlayerJoinRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	return n
}

func (m *S2C_UpdatePlayerLeaveRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovMatch(uint64(e))
		}
		n += 1 + sovMatch(uint64(l)) + l
	}
	return n
}

func sovMatch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMatch(x uint64) (n int) {
	return sovMatch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetChip", wireType)
			}
			m.BetChip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetChip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Room) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Room: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Room: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBet", wireType)
			}
			m.MaxBet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_QuickMatchStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_QuickMatchStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_QuickMatchStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_QuickMatchStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_QuickMatchStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_QuickMatchStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (S2C_QuickMatchStart_E_Err_QuickMatchStart(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &Room{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_PlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_PlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_PlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_PlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_PlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_PlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= (S2C_PlayerLeaveRoom_E_Err_PlayerLeaveRoom(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_UpdatePlayerJoinRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_UpdatePlayerJoinRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_UpdatePlayerJoinRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_UpdatePlayerLeaveRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_UpdatePlayerLeaveRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_UpdatePlayerLeaveRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMatch
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIds) == 0 {
					m.UserIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMatch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMatch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMatch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMatch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMatch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("match.proto", fileDescriptor_match_e89479ba4cb4f4b2) }

var fileDescriptor_match_e89479ba4cb4f4b2 = []byte{
	// 464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0xc1, 0x6e, 0xd3, 0x30,
	0x18, 0xc7, 0xeb, 0xb8, 0x4b, 0xe9, 0x57, 0xad, 0x0a, 0x9e, 0x36, 0x19, 0x04, 0x51, 0x14, 0x09,
	0x29, 0xa7, 0x1c, 0x82, 0xb8, 0xb3, 0x56, 0x3d, 0x14, 0xb6, 0x69, 0xb8, 0xea, 0x81, 0xd3, 0x64,
	0x52, 0x6b, 0xab, 0xb6, 0x34, 0x95, 0x93, 0x0d, 0x38, 0xf0, 0x0e, 0x3c, 0x03, 0x0f, 0xc0, 0x73,
	0x70, 0x1c, 0x37, 0x8e, 0xa8, 0x7d, 0x11, 0xe4, 0xcf, 0xc9, 0x5a, 0x85, 0x4d, 0xbb, 0x7d, 0xdf,
	0xcf, 0xf6, 0xff, 0xfb, 0xff, 0x2d, 0x1b, 0x7a, 0x99, 0x2c, 0xd3, 0x8b, 0x78, 0xa9, 0xf3, 0x32,
	0x67, 0x34, 0x2b, 0xce, 0xc3, 0x9f, 0x04, 0xdc, 0xd3, 0x2b, 0xf9, 0x55, 0x69, 0x76, 0x00, 0xee,
	0xb4, 0x50, 0x7a, 0x3c, 0xe3, 0x24, 0x20, 0x11, 0x15, 0x55, 0xc7, 0x9e, 0xc3, 0x93, 0x93, 0x79,
	0x7a, 0x79, 0x22, 0x33, 0xc5, 0x9d, 0x80, 0x44, 0x5d, 0x71, 0xd7, 0xb3, 0x17, 0xd0, 0x3d, 0xbc,
	0x91, 0xa5, 0xd4, 0x53, 0x71, 0xc4, 0x29, 0x2e, 0x6e, 0x00, 0xf3, 0x80, 0x9e, 0xe6, 0x05, 0x6f,
	0x07, 0x24, 0xda, 0x15, 0xa6, 0x64, 0x0c, 0xda, 0x22, 0xbf, 0x52, 0x7c, 0x27, 0x20, 0xd1, 0x8e,
	0xc0, 0xda, 0xb0, 0xe1, 0xc5, 0x7c, 0xc9, 0x5d, 0x9c, 0x8a, 0x35, 0xe3, 0xd0, 0x19, 0xa8, 0x12,
	0x71, 0x07, 0x71, 0xdd, 0x86, 0xdf, 0x8c, 0x42, 0x9e, 0xb1, 0x3e, 0x38, 0x95, 0xd3, 0xb6, 0x70,
	0xc6, 0x33, 0xa3, 0xb2, 0xe5, 0x10, 0x6b, 0xf6, 0x0a, 0x3a, 0x36, 0x5b, 0xc1, 0x69, 0x40, 0xa3,
	0x5e, 0xd2, 0x8b, 0xb3, 0xe2, 0x3c, 0xb6, 0x4c, 0xd4, 0x6b, 0x77, 0x06, 0xda, 0x5b, 0x06, 0x0e,
	0xc0, 0x3d, 0x96, 0x5f, 0x06, 0xaa, 0x44, 0xab, 0x54, 0x54, 0x5d, 0xb8, 0x0f, 0x7b, 0xc3, 0x64,
	0x72, 0xf6, 0xe1, 0x7a, 0x9e, 0x5e, 0x1e, 0x9b, 0xcb, 0x9c, 0x94, 0x52, 0x97, 0xe1, 0x6f, 0x02,
	0x7b, 0x93, 0x64, 0xd8, 0xe4, 0xec, 0x2d, 0xd0, 0x91, 0xd6, 0x68, 0xb3, 0x9f, 0xc4, 0x38, 0xfd,
	0x9e, 0x6d, 0xf1, 0xe8, 0x6c, 0xa4, 0x75, 0x93, 0x0a, 0x73, 0x94, 0xbd, 0xb4, 0x79, 0x31, 0x57,
	0x2f, 0xe9, 0xa2, 0x84, 0x01, 0x02, 0x71, 0xf8, 0x11, 0xf6, 0xef, 0x3d, 0xcc, 0x00, 0x5c, 0xbb,
	0xe0, 0xb5, 0xd8, 0x53, 0xd8, 0xb5, 0xf5, 0xe4, 0x3a, 0x4d, 0x55, 0x51, 0x78, 0x84, 0xf5, 0x01,
	0x2c, 0x32, 0x2a, 0x9e, 0xb3, 0xd9, 0x32, 0x5d, 0xbc, 0x5f, 0xe4, 0x9f, 0x17, 0x1e, 0xad, 0xa3,
	0xda, 0x5b, 0x3a, 0x52, 0xf2, 0x46, 0xe1, 0xc4, 0x1f, 0x55, 0xd4, 0x06, 0x7f, 0x28, 0x6a, 0x63,
	0x5b, 0x15, 0xb5, 0x41, 0x31, 0x6a, 0x38, 0xae, 0xb3, 0x34, 0xa5, 0x1f, 0xc9, 0xf2, 0x9f, 0x77,
	0x27, 0x3c, 0x04, 0x6e, 0x86, 0x4f, 0x97, 0x33, 0x59, 0x2a, 0x2b, 0xf7, 0x2e, 0x9f, 0x2f, 0x50,
	0x6d, 0xeb, 0x55, 0x90, 0x87, 0x5f, 0x45, 0xf8, 0x06, 0x9e, 0x35, 0x25, 0x36, 0x8e, 0x38, 0x74,
	0xec, 0xef, 0xb0, 0x1a, 0x54, 0xd4, 0xed, 0x80, 0xff, 0x5a, 0xf9, 0xe4, 0x76, 0xe5, 0x93, 0xbf,
	0x2b, 0x9f, 0x7c, 0x5f, 0xfb, 0xad, 0xdb, 0xb5, 0xdf, 0xfa, 0xb3, 0xf6, 0x5b, 0x9f, 0x5c, 0xfc,
	0x76, 0xaf, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x1c, 0xd5, 0x63, 0x85, 0x03, 0x00, 0x00,
}
